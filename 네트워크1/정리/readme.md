# 네트워크 1 정리
> 네트워크<br>
- 전송매체를 통해 서로 연결된 시스템 모음
---
> 네트워크 주소<br>
- 네트워크와 네트워크를 구분하기위해 사용
---
> 네트워크의 특징<br>
```
1. 유일성
2. 확장성
3. 편의성
4. 정보의 함축성
```
---
> 계층구조의 장점<br>
```
1. 전체 시스템을 이해하기 쉬움, 설계와 구현이 쉬움
2. 시스템 구조를 단순화 가능
3. 특정 모듈의 외부인터페이스가 변하지 않음 -> 내부기능의 변화가 전체시스템에 영향을 미치지않음
4. 대칭 구조에서는 동일 계층 사이의 protocol을 단순화 가능
```
---
> 흐름제어의 필요성<br>
- 수신 호스트의 버퍼처리 속도보다 데이터 전송속도가 빠르면 발생하는 문제점을 해결하기 위해
---
> 서비스 프리미티브<br>
```
- Request : C -> S 요청
- Idication : S에 요청이 도착함을 통지
- Response : S -> C 응답
- Confirm : C에 응답이 도착했음을 통지
```
---
> OSI 7 계층중 데이터 경로 설정<BR>
- 네트워크 계층의 라우팅 기능이며, 네트워크 계층에서는 혼잡제어 기능도 수행
---
> 회선 교환 방식<br>
```
- 연결형 서비스
- 음성전화 서비스를 통해 발전
- 고정대역폭의 전송율 지원
- 네트워크 구조 단순
```
---
> 패킷 교환 방식<br>
```
- 컴퓨터 네트원크 환경에서 주로 사용
- 비연결형
- 가변대역 전송률 지원
- 네트워크 구조 복잡
- 패킷 전송경로 결정이 가장 중요
```
---
> 패킷교환 방식중 가상회선과 데이터그램의 차이<br>
```
1. 가상회선
- 일정한 경로
- 정보 도착 순서가 일정
2. 데이터 그램
- 서로 다른 경로
- 정보양이 적은 환경에서 사용
- 정보 도착 순서가 일정하지 않음
```
---
> 프레임 릴레이와 셀릴레이의 등장배경
```
- 패킷교환 고안된 시절에 원거리 디지털통신 과정에서 전송오류 발생이 많아짐
- 물리적 전송오류를 해결하기 위해 다량의 오버헤드 비트가 추가
- 송수신 시스템의 오류처리과정 복잡
- 교환시스템에 오류를 검색하고 복구하는 기능 필요
```
---
> 라우터 <br>
- 패킷의 올바른 전송을 위해 ip프로토콜까지의 계층 기능을 지원
---
> ip인터네트워킹<br>
- 인터넷에서 ip프로토콜을 이용하여 네트워크를 연결하는 방식
---
> 고정 경로 배정<br>
```
- 간단한 구현으로 효과적인 라우팅가능
- 송수신 호스트 사이에 영수 불변의 고정경로를 배정
- 전송경로가 고정 -> 트래픽 변화에 따른 동적 경로 배정 불가
```
---
> 적응 경로 배정<br>
```
- 라우터 사이의 시간적인 정보의 불일치성 문제가 항상 존재
- 인터넷 연결상태 변화 -> 이를 전달경로 배정에 반영
- 특정 위치에서의 어떤 변화를 네트워크의 모든 라우터에 동시 반영은 불가능
```
---
> 서비스 품질의 판단 기준<br>
```
- 데이터 분실
- 전송 지연
- 지연 값의 일관성
```
---
> 서비스 품질의 매개변수 <br>
```
- 연결설정 지연
- 연결설정실패 확률
- 전송률, 전송 지연
- 전송 오류률, 우선순위
```
---
> 컴퓨터 네트워크의 효과<br>
```
- 자원공유
- 병렬처리에 의한 성능향상
- 중복 저장으로 신뢰성 향상
```
---
> 점대점 방식<br>
```
- 스타형
- 링형
- 완전형
- 불완전형
```
---
> 브로드캐스팅 방식<br>
```
- 버스형
- 링형(토큰 use)
```
---
> 유니캐스팅<br>
```
- 1대1 통신방식
- 컴퓨터의 가장 기본적인 통신방식
- 인터넷으로 제공되는 텔넷, FTP, 웹검색 서비스를 제공
```
---
> 멀티포인트 유니캐스팅 <br>
```
- 프로토콜 자체에서 일대다 전송기능 구현
- 다수 연결설정이 필수
- 수신 호스트 수많큼 데이터를 반복전송
- 수신호스트가 많아지면, 성능에서 문제 발생
```
---
> 멀티캐스팅<br>
```
- 프로토콜자체에서 일대다 전송기능
- 송신 호스트의 전송요구한번으로 모든 수신 호스트에 데이터 전달가능
- 등롣된 다수 고객을 대상
```
---
> 브로드 캐스트의 단점<br>
- 호스트 수가 많을수록 네트워크 트래픽이 급격히 증가
---
> 타임아웃<br>
- 송수신 호스트 사이에서 데이터 프레임을 전송한 이후 일정시간이내에 수신호스트로부터 긍정 또는 부정응답이 오지않으면 재전송하는 기능(=오류복구)
---
> 순서번호<br>
- 오류가 발생하여 재전송시 프레임이 중복수신을 방지할 수 있다.
---
> 송수신호스트에서 발생가능한 전송오류<br>
```
- 프레임 변형
- 송신측 프레임 분실
- 수신측 프레임 분실
```
---
> 흐름제어<br>
```
- 수신호스트가 감당할 수 있을 정도의 속도를 유지하면서 데이터 프레임을 전송하여 프레임 분실로 인한 재전송을 방지하기 위함
- 수신호스트의 내부버퍼의 크기에 맞게 데이터 전송
- 흐름제어가 없을시 프레임 분석과 동일한 효과 발생
```
---
> 데이터링크계층의 전송프레임<br>
- 체크섬, 송수신 호스트의 주소, 제어코드등을 포함
---
> 점대점 방식<br>
- 하나의 데이터를 전송후 수신측에서 응답메세지를 받은 이후 다음 데이터 전송 -> 흐름제어가 필요없음
---
> 슬라이딩 윈도우 프로토콜<br>
- 흐름제어의 대표적 protocol
---
> 비트프레임<br>
```
- 프레임의 시작과 끝에 플래그 비트패턴을 추가 -> 프레임 단위를 구분
- 수신호스트에서는 플래그 비트 패턴을 제거하여 상위계층으로 전달
- 송신호스트에서는 전송데이터가 1이 연속해서 5번 발생시 강제로 0 추가
```
---
> 문자 프레임<br>
```
- 프레임의 시작과 끝에 DEL/STX와 DEL/ETX를 추가해서 구분
- 프레임 정보에 DLE/ETX가 있을 시 DLE과 ETX사이에 DLE을 추가 삽입
```
---
> 오류 검출 코드<br>
```
- 오류 복구를 위해서 전송프레임에 넣어, 수신측에서 오류를 검출함
- 순방향, 역방향 오류 복구 기능이 있음
```
---
> 오류검출에 사용되는 방식<br>
```
- 패리티 비트 : 데이터 끝에 패리티 비트를 추가해서 오류를 검출 & 수정은 불가능
- 블록 검사 : 패리티 비트의 문제점을 해결하기위해 수직/수평 방향으로 패리티 비트를 추가하여 오류를 검출하는 방법
- 다항 코드
```
---
> 역방향 오류복구<br>
```
- 재전송방식을 이용해 오류복구 수행
- ARQ방식
```
---
> 데이터 링크 계층<br>
```
- MAC 계층 : 물리계층의 기능 수행
- LLC 계층 : 데이터 링크 계층의 기본기능 수행
```
---
> 공유메체를 이용한 데이터 전달방법<br>
- 충돌문제를 해결하기 위해
```
- CSMA/CD : 충돌감지 기능 필수적
- 타임슬롯 방식 : 시간대를 나누어 데이터 전송
---- 재전송기능을 오류를 복구 ----
```
---
> IEEE 802 시리즈<br>
```
- 802.1 : 표준안 전체
- 802.2 : LLC계층 소개
- 802.3 : 다양한 환경의 MAC계층
- 802.4 : CSMA/CD
- 802.5 : 토큰 버스
- 802.6 : 토큰 링
```
---
> 데이터 프레임<br>
- 출발지 주소와 목적지 주소가 반드시 포함
---
> CSMA/CD에서 신호 감지 프로토콜<br>
```
- 1-persistent CSMA
- Non-persistent CSMA
- P-persistent CSMA
- CSMA CD
```
---
> 프레임 구조<br>
preamble | start Delimiter | D.A | S.A | length or type | Date | checksum
---
> 토큰버스의 구조<br>
preamble | start Delimiter | frame control | D.A | S.A | length or type | Date | checksum | end Delimiter
```
frame control필드 : 0  0 : 제어용 MAC 프레임
                  : 0  1 : LLC 프레임
                  : 1  0 : 네트워크 관리용 데이터 프레임
                  : 1  1 : 예약
```
> 토큰링의 구조<br>
SD | AC | FC | D.A | S.A | Data | checksum | ED | FS
```
- SD, AC ,ED : 토큰
- SD : Start Delimiter 시작 구분자
        I 비트 : 데이터 프레임 여러개로 나누어 전송
        E 비트 : 오류검출용

- AC : Access control 접근 제어
        P : 우선순위
        T : 토큰 -> 토큰프레임의 값이 0
        M : 모니터 -> 오류발생시 링 주위를 무한정 순환을 막기위해 사용
        R : 예약

- FC : Frame control 프레임 제어
        0 0 : 제어용 MAC프레임
        0 1 : LLC 프레임
        1 X : 예약

- ED : End Delimiter 끝 구분자
        A 비트 : 수신호스트가 접근 -> 1
        C 비트 : 수신호스트가 자신의 내부 버퍼에 보관했다고 표시로 '1'지정

- FS : Frame state 프레임 상태
```
---
> LLC 프레임 캡슐화 <br>
```
- 필수
- 좌우에 토큰버스 프레임의 헤더와 트레일러 정보가 채워가면 물리계층이 수신호스트로 전송
```
---
> 점대점 방식<br>
```
- 라우팅 과정 없이 전달이 가능
- 전송오류 감지 및 복구 기능을 지원
- 주소 개념 필요 x
```
---
> 멀티 드롭 방식<br>
```
- 라우팅 과정 필요
- 주소 개념이 필요
```
---
> 단순 프로토콜<br>
```
- 송신 호스트가 원하는 만큼 자유롭게 프레임 전송 가능
- 오류제어&흐름제어가 필요 없음
```
---
> 프레임의 종류<br>
```
- 정보 프레임 : 수신 호스트에 데이터를 전송하는 용도
- 긍정 응답 프레임 : 전송 데이터가 올바르게 도착했음을 회신하는 용도
- 부정 응답 프레임 : 전송과정에서 프레임 변형 오류가 발생했음을 회신하는 용도도
```
---
> 정지 대기 프레임<br>
```
- 수신호스트 버퍼의 개수가 제한일 경우 흐름제어 기능으로 송신호스트의 전송속도를 조절
- 한번에 여러개의 프레임 전송 X
- 한번에 하나의 데이터 전송후 수신호그트로부터 ACK프레임을 수신해야만 다음 프레임을 전송
CF) 단순 프로토콜 : 흐름제어, 오류제어 필요없음
```
---
> 양방향 통신<br>
- 오류제어와 흐름제어를 위해 슬라이딩 윈도우 프로토콜을 사용
---
> 오류복구를 위한 재전송<br>
```
- 선택적 재전송 : 송수신 윈도우의 크기가 동일, 오류가 발생한 프레림만 선택적으로 복구
- 고백 N 방식 : 송수신 윈도루의 크기가 1, 오류가 발생한 프레임을 포함하여 이후에 전송된 모든 정보프레임을 재전송
```
---
> 피기 배킹 방식<br>
- 정보 프레임을 전송하면서 응답기능까지 함께 수행 => 전송 효율이 올라감
---
> 슬라이딩 윈도우 프로토콜<br>
```
- 연속형 전송 방식
- 정지- 대기 프로토콜은 송수신 윈도우의 크기가 1인경우
- 연속형 정지 방식은 ack프레임을 받지않고 여러프레임을 연속 전송 가능
- 오류가능성이 적은 환경에서 효율적
```
---
> HDLC의 호스트<br>
```
- 주국 : 메세지를 전송 -> 송신 호스트
- 종국 : 회신 -> 수신 호스트
- 혼합국 : 주수, 종국 기능을 모두 가정 -> 송수신 호스트
```
---
> HDLC의 프레임<br>
```
- 정보 프레임 : 네트워크 계층의 데이터 전송을 위해 정의, 3비트의 순서번호를 이용한 슬라이딩 윈도우 프로토콜을 사용
- 감독 프레임 : 긍정 응답 프레임과 부정 응답 프레임으로 나뉨
- 비번호 프레임 : 순서번호가 없는 프레임
```
---
> 정보 프레임 <br>
```
- 0 ~7 의 순서번호 8개를 순환하여 사용
- Seq : 정보 프레임의 송신룔 순서 번호로 사용
- Next : 피기배킹을 이용한 응답 기능으로 사용
- P/F : 값이 1로 지정되었을 경우에 한하여 Poll 혹은 Final의 의미를 가짐
```
---
> 감독 프레임<br>
```
- 응답기능을 수행하는 프레임
- Type 0 : RR로 정의된 긍정 응답 프레임
- Type 1 : REJ로 정의된 부정 응답 프레임
- Type 2 : RNR로 정의괸 응답 프레임으로 흐름 제어 기능까지 제공
- Type 3 : SREJ로 정의된 프레임, 선택적 재전송 방식에서 부정 응답 기능을 지원
```
---
> 비번호 프레임 <br>
```
<연결필드>
  - 정규 응답 모드(SABM)
  - 비동기 균형 모드(SNRM)
  - 비동기 응답 모드(SARM)
<오류>
  - RSET : 비정상적인 프로토콜의 동작에 따른 리셋 기능
  - FRMR : 비정상적인 프레임의 수신을 거부
  - UA : 비번호 프레임에 응답 기능을 수행
<연결 설정 해제>
  - DISC
```
---
> 혼잡과 혼잡제어<br>
```
- 혼잡 : 네트워크에 패킷이 과도하게 증가되는 현상
- 혼잡제어 : 혼잡의 발생을 예방이나 제거하는 기능
```
---
> 연결형 서비스와 비연결형 서비스<br>
```
- 연결형 서비스 : 데이터 전송전 데이터의 경로를 미리 결정, TCP
- 비연결형 서비스 : 패킷의 100%도착을 보장 x, 상위계층에서 패킷 분실 오류를 복구해야 한다, 경로를 사전에 결정하지 않음, 패킷 단위로 결정
                 : IP, UDP
                 : 패킷의 전달 순서가 일정하지 X -> 재조정이 필요
```
---
> 소스라우팅<br>
```
- 경로 정보를 전송 패킷에 기록해서 보내는 방식
- 데이터그램방식과 가상회선 방식에서 모두 이용이 가능
- 패킷을 전송하는 호스트가 목적지 호스트까지 전달 경로를 스스로 결정
```
---
> 분산라우팅<br>
```
- 라우팅 정보가 분산되는 방식
- 네트워크에 존재하는 호스트의 수가 많아질수록 다른 방식보단 효과적적
```
---
> 플러딩<br>
```
- 라우터가 자신에게 입력된 패킷은 출력가능한 모든 경로로 중개하는 방식
- 특별한 목적으로만 사용
- 패킷이 무한히 만들어 질 수 있으므로, 생존시간을 제한
```
---
> 거리벡터 라우팅 프로토콜의 필수 정보<br>
```
- 거리 벡터
- 링크 벡터
- 다음 홉 벡터
```
---
> IPv6<br>
```
- 주소공간의 확장, 헤더 구조의 단순화
- 프로토콜의 전송효율을 향상, 흐름제어 기능을 지원
- 실시간 멀티 미디어 응용 환경을 수용
```
---
> 터널링<br>
- 상이한 IP프로토콜을 교체하는 방식
```
<동작원리>
1. 새로운 위치를 관장하는 포린 에이전트 Fanew로부터 COA(Care of Address)를 얻음
2. 이 주소는 이동 호스트의 홈 에이전트 HA에 등록되어 FAnew와 HA사이에 터널을 형성
3. HA로 라우팅된 패킷을 이동 호스트에 전달하려면 새로 형성된 터널을 통해 FAnew로 전달
4. 이동 호스트에는 고유 IP주소인 홈 주소 HA가 할당, 호스트 위치가 바뀌어도 변하지 않음
5. COA는 이동 호스트가 새로 이동한 지역에서 일시적으로 할당된 IP주소 호스트가 이동할 때마다 새로운 COA가 할당되 기존의 COA는 회수되는 과정이 반복됨
```
---
> IPv6의 확장헤더<br>
```
- Hop-by-Hop Options Header : Jumbo 페이로드 옵션 -> 데이터의 크기가 65535 바이트보다 클 때 사용
                            : 라우터 긴급 옵션 -> 라우터에 전송 대역 예약 같은 특정 정보를 제공
- Routing Header : IPv4의 소스 라우팅과 유사한 기능, 지정된 특정 노드를 경유하여 전송
- Fragment Header
- Destination Option Header : 수신호스트가 확인할 수 있는 옵션 정보
- Authentication Header : 패킷 인증 관련 기능
- Encapsulation Security Payload Header : 프라이버시 기능
```
---
> ARP프로토콜<br>
```
- 특정 호스트의 IP주소로부터 MAC주소를 제공하는 프로토콜
- ARP Request라는 특수한 패킷을 브로드 캐스팅한다.
- IP주소에 해당하는 호스트만 ARP replay로 MAC주소를 회신한다
- 효율향상을 위해 캐시기능을 제공
```
---
> ICMP프로토콜<br>
```
- 인터넷 환경에서 오류에 관한 처리를 지원하는 프로토콜
- IP프로토콜에 캡슐화되어 전송
```
---
> ICMP 오류보고 메세지<br>
```
- Destination unreacherable
- Source quench
- Time exceeded
```
---
> IGMP프로토콜<br>
```
- 특정 그룹의모든 호스트에게 메세지를 전송하거나 멀티 캐스팅에 필요한 라우팅 알고리즘
- IP패킷에 캡슐화되어 전송
```
---
> IGMP의 주요기능<br>
```
- 그룹의 생성 및 제거
- 전송 호스트의 그룹 참가및 탈퇴
```
---
> TCP<br>
- 연결형 서비스를 제공, 전이중 방식의 양방향 가상회건을 제공, 신뢰성 있는 데이터 전송을 보장
---
> 멀티 플렉싱<br>
```
- 상방향 멀티 플렉싱 : 다수의 전송계층 연결에 대해 하부의 네트워크 계층에서 연결 하나를 형성
                    : 네트워크계층에서 만들어지는 가상회선 연결 개수를 줄일 수 있다.
- 하방향 멀티 플렉싱 : 하나의 전송연결 설정을 의미하는 포트에 다수의 가상 회선을 할당한다,
                    : 전송속도를 높이고, 데이터의 특성에 따라 개별 가상회선을 할당한여 효과적인 통신이 가능하다.
```
---
> UDP<br>
```
- 비연결 서비스를 제공
- 데이터 처리가 빠름 -> 데이터 전송 시간에 민감한 응용 환경에서 사용하는 것이 유리
```
---
> RTP<br>
```
- 실시간 멀티미디어 데이터 전송을 지원, 유니캐스팅과 멀티캐스팅 모두 지원
- 불규칙한 데이터의 순서를 정렬하기 위해 타임 스탬프 방식을 사용
```
---
> 지터 분포 <br>
- 데이터그램의 도착시간이 불규칙적으로 도착하는 정도를 나타내는 것
---
> RTP의 데이터 전송<br>
```
- 실시간 서비스를 위해 작고 빠른 전송 기능을 제공하는 UDP위에서 구현한다
- 하나의 완전한 프로그램단위를 구현하지 않고, 기능별로 개별 구현
- 데이터그램 분실이나 도착순서 변경과 같은 전송오류는 UDP자체에서 해결
- 다수의 사용자가 하나의 세션에 참여하여 서로 실시간 데이터 전송이 가능하도록 지원
```
---
> RTP 헤더에 정의된 필드<br>
```
- Version : RTP의 버전 번호
- Padding : RTP 페이로드의 마지막에 패딩 데이터가 존재하는 여부
- Extension : 고정 헤더의 마지막에 확장 헤더가 하나 더 이어짐을 의미
- CSRC Count : CSRC 구분자의 개수를 표시
- Marker : 임의의 표식, 페이로드 유형에 따라 값의 의미가 결정됨
- Payload Type : 헤더 다음에 이어지는 RTP 페이로드의 유형
- Sequence Number : Timestamp 필드 값이 동일한 페이로드에 대해 패킷 손실이나 순서 변경과 같은 오류 검출
- Timestamp : RTP 페이로드에 포함된 데이터의 생성 시기
- SSRC Identifier(SSRC 구분자) : 임의의 세션 내에서 RTP 페이로드의 발신지가 어디인지를 구분하는 고유 번호
```
---
> 믹서 & 트랜슈에이터<br>
```
믹서 : RTP 데이터그램 스트림을 받아 이들을 적절히 조합하여 새로운 데이터그램 스트림을 생성
트랜슬레이터 : 입력된 각 RTP 데이터그램을 하나 이상의 출력용 RTP데이터그램으로 만들어주는 장치
```
---
> RTP 제어 프로토콜(RTCP) 주요기능<br>
```
- QoS와 혼잡 제어 : 데이터 분배 과정에서 발생하는 서비스 품질에 관한 피드백 기능을 지원
- Identification(구분자) : RTCP 송신 프로세스에 관한 구분자 정보가 포함
                         : 서로 다른 세션에서 발신된 스트림 정보들을 서로 연관시키는 근거를 제공
- 세션 크기 : 전체 세션 트래픽의 5%이내로 유지되도록 알고리즘이 동작
```
---
> OSI TP프로토콜<br>
```
클래스 0 : 기본 기능
클래스 1 : 기본 오류 복구 기능
클래스 2 : 멀티플렉싱 기능
클래스 3 : 오류 복구, 멀티 플렉싱 기능
클래스 4 : 오류 검출, 오류 복구, 멀티플렉싱 기능
```
---
> OSI TP 서비스 프리미티브<br>
```
- T-CONNECT.request : 연결 설정
- T-CONNECT.indication : 연결 설정
- T-CONNECT.response : 연결 설정
- T-CONNECT.confirm : 연결 설정
- T-DISCONNECT.request : 연결 해제
- T-DISCONNECT.indication : 연결 해제
- T-DATA.request : 데이터 전송
- T-DATA.indication : 데이터 전송
- T-EXPEDITED.request : 긴급 데이터 전송
- T-EXPEDITED.indication : 긴급 데이터 전송
- T-UNITDATA.request : 비연결 데이터 전송
- T-UNITDATA.indication : 비연결 데이터 전송송
```
---
> 세션계층<br>
```
- 세션연결의 설정과 해제
- 메시지 전송
- 동기 기능
- 대화 단계
```
---
> 토큰의 종류<br>
- 두 응용 프로세스의 대화를 관리
- 토큰 보유는 토큰에 부여된 특정한 권리를 배타적으로 수용한다는 의미
```
- 데이터 토큰 : 데이터를 전송할 수 있는 권리 제공
- 해제 토큰 : 통신 양단 간의 연결해제 과정을 제어하기 위해 사용
- 동기 토큰 : 세션 연결을 사용하는 과정에서 동기 처리가 필요한 지점에 사용
```
---
> 재동기 기능<br>
- 동기점을 이용한 일련의 복구 과정
```
- 주동기점 : 주동기점이 설정된 곳은 완벽히 처리되었다는 의미
          : 주동기점 이전의 복구 과정은 필요하지 않음
- 부동기점 : 복구에 필요한 백업 정보가 상대적으로 적음
          : 오류 복구가 완벽히 이루어지지 않을 수 있음
          : 이전 부동기점에서 복구가 불가능하면 직전 부동기점으로 이동하는 과정을 반복
```
---
---
> 표현계층에서 ASN.1 규약에서 지원하는 클래스 유형<br>
```
- UNIVERSAL : 일반 데이터형
- CONTEXT-SPECIFIC : 특정 컨텍스트와 관련된 유형
- APPLICATION : 응욜 개체의 공통 유형
- PRIVATE : 사용자 정의 유형
```
---
> 압축<br>
```
- 손실 압축 : 압축 과정에서 원래 데이터의 내용을 부분적으로 분실
            : 압축 해제 과정을 통해 원래의 데이터를 100% 복원할 수 없음
            : 압축 효율을 높이기 위하여 사용
- 비손실 압축 : 압축 과정에서 원래 데이터의 내용을 분실하지 않음
              : 압축 해제 과정을 통해 원래 데이터를 100% 복원
```
---
> 동시성<br>
```
- 임의의 여러동작이 외형상 동시에 진행되는 것처럼 보이는 현상
- 여러 동작의 선후 진행속도가 실행결과에 영향을 미치지 않음
- 단일 CPU가 장착된 컴퓨터에서 여러 프로세스가 실행되는 경우
```
---
> 동시성 제어<br>
- 독립적으로 실행되는 프로세스의 실행순서가 결과에 영향을 주지 않음
---
> 소켓의 주소 체계<br>
- 프로그래밍 환경에서 AF_UNIX와 AF_INET 소켓 주소 체계 가장 많이 사용
---
> 유닉스 주소 체계 AF_UNIX<br>
```
- 하나의 호스트 내부에서 실행되는 프로세스 사이의 통신을 지원
- 사용하는 주소 체계는 파일 시스템의 경로병을 기반으로 함
```
---
> 인터넷 주소 체계 AF_INET<br>
```
- 서로 다른 호스트에서 실행되는 프로세스 사이의 통신을 지원
- 소켓이 생성되는 호스트의 32비트 IP주소와 16비트의 포트 번호를 조합하여 소켓 주소 표현
```
---
> 통합 주소 체계<br>
```
- 운영체제에서 제공하는 통신 프로토콜마다 주소 체계를 지원하는 문법 구조가 다름
- 소켓 주소의 사용은 동일한 소켓 시스템 콜을 통해 이루어짐
- 의미는 같으나 형식이 다른 여러 구조체를 하나의 함수에서 수용하는 것은 문법적으로 불가능
- 따라서 모든 주소 체계를 수용할 수 있는 공통 주소체계가 필요함
- 프로그래밍 환경에서의 문법적인 측면만 고려하여 정의
```
---
> 소켓의 서비스<br>
- 제공되는 서비스 종류에 따른 소켓 유형도 다양하게 존재
---
> 소켓의 유형<br>
```
- SOCK_STRAM : 연겷형 서비스를 제공받을 때 사용
- SOCK_DGRAM : 비연결형 서비스에서 사용
- SOCK_RAW : IP 프로토콜을 직접 사용해 통신할 때 사용
```
---
> 소켓 시스템의 시스템 콜<br>
1. socket() 함수
```
- 데이터 전송에 사용되는 소켓을 생성할 때 호출
- 소켓을 성공적으로 생성하면 소켓 디스크립터를 반환함
```
2. bind() 함수
```
- 생성된 소켓에 주소를 부여함
```
3. listen() 함수
```
- 소켓에서 대기할 수 있는 클라이언트의 연결요청 개수를 지정
```
4. accept() 함수
```
- 서버 프로그램에서 클라이언트의 연결요청을 대기
```
5. connect() 함수
```
-  연결형 서비스에서 클라이언트 프로세스가 서버 프로세스에 연결 요청
```
6. send() 함수
```
- send() 함수 : 연결형 서비스에서 데이터 송신에 사용
- sendto() 함수 : 비연결형 서비스에서 사용
```
7. recv() 함수
```
- 상대 프로세스가 전송한 데이터를 소켓을 통해 읽음
- recv() 함수 : 연결형 서비스에서 사용
- recvfrom() 함수 : 비연결형 서비스에서 사용
```
---
> 연결형 서비스<br>
- 소켓 : 네트워크 통신을 위한 소프트웨어 교신점
---
> 서버와 클라이언트의 동작<br>
- Well-known 포트로 자신의 소켓 주소를 설정
---
> 비연결형 서비스<br>
```
- connect()와 accept() 함수를 사용
- 데이터 송수신을 위한 sendro(), recvfrom() 함수 사용
- 전송 데이터마다 수신자의 포트 번호 함께 전송
```
---
> PHP 코드의 처리<br>
```
- HTML 문서 내용의 일부로 작성되며, <? 와 ?> 구분자를 사용
- PHP 코드가 포함된 HTML 문서는 확장자가 .php
- 웹 브라우저에 회신되는 내용 : PHP 코드는 서버에서 실행되고 결과만 회신
```
---
> HTML(HyperText Markup Language)<br>
- 웹 문서를 작성하는 언어
---
> 프레임 태크<br>
- 한 화면을 여러 프레임으로 나누는 기능
---
> HTTP(Hyper Text Transfer Protocol)<br>
```
- 웹 문서를 전송하는 프로토콜로 TCP 80번 사용
- 요청 메서드(Request Method) : 클라이언트가 서버에 실행을 요구하는 명령을 기술
* 요청 메서드의 명령
  - GET : 클라이언트가 서버에 URL이 가리키는 웹문서의 내용을 전송하도록 요구한다
        : 문서 내용은 서버가 회신하는 응답 메시지의 바디에 포함된다.
  - HEAD : 문서 내용보다는 특정 문서의 정보를 원할 때 사용
  - POST : 클라이언트가 서버에 정보를 전송할 수 있도록 해준다
         : 보통 게시판, 방명록처럼 사용자가 입력한 정보를 서버에 전달하는 용도로 사용
  - PUT : 클라이언트가 서버에 문서를 전달하려고 사용한다
        : 문서 내용은 바디에 포함
```
---
> CGI(Common Gateway Interface)<br>
```
- 사용자가 입력하는 정보를 처리
- C, C++, 셸(Shell), 펄(Perl) 등과 같은 언어로 작성되어 서버에서 실행되는 프로그램
```
---
> 도메인 네임 스페이스<br>
```
- 트리 구조의 네임 스페이스를 비롯해 데이터에 대한 이름 관련 규칙을 정의
- 트리에 연결된 호스트는 자원 레코드로 표현
- DNS 서비스는 자원 레코드의 특정 유형의 정보를 얻는 과정
- DNS가 저장, 관리하는 계층적 데이터베이스
- 최상위에 루트가 존재, 그 아래로 모든 호스트가 트리 구조로 이어짐
- 레이블 : 호스트의 이름
- 도메인 이름 : 점(.)으로 구분한 호스트 레이블의 연속
```
> 네임 서버<br>
```
- 도메인 트리 구조와 트리에 보관된 자원 레코드를 관리하는 프로그램
- 여러 네임 서버가 구역을 분할 해 전체 도메인을 관리함
```
> 해석기(resolver)<br>
```
- 클라이언트의 요청을 받아 네임 서버로부터 정보를 얻어냄
- 하나의 이상의 네임 서버와 접촉
```
> 도메인 네임 스페이스의 구조<br>
```
- 계층적인 트리 구조를 지원
- 도메인 이름 : 최상위 호스트의 레이블을 맨 왼쪽에 두고, 상위 노드로 이동하면서 점(.)으로 구분한 레이블 이름을 연속으로 붙임
- TLDTop LevelDomain : 최상위 도메인, 도메인 이름의 맨 오른쪽에 위치
- 도메인 : 도메인 네임 스페이스에서 하부 트리 전체를 의미, 해당 도메인의 명칭은 하부 트리의 맨 상위에 위치한 호스트의 도메인 이름
```
---
> 데이터베이스 서비스<br>
```
- 계층 구조의 내임 서버
-  각 네임 서버는 자신의 하부에 위치한 호스트 정보만을 관리
- 이웃하는 네임 서버끼리 정보가 필요할 때는 상위 네임 서버의 중개가 필요
```
---
> 도메인 영역<br>
- 존(zone) : 임의의 네임 서버가 관리하는 영역
---
> 자원 레코드<br>
```
- 이름과 주소 정보를 저장하기 위한 레코드
- 트리에 연결된 각 호스트의 정보는 자원 레코드와 관계됨
- DNS 네임 서버가 해석ㄷ기에 반환하는 데이터가 자원 레코드 정보
- 질의 레코드 : DNS 클라이언트가 DNS 서버에 정보를 요청하는 용도
```
---
> 자원 레코드 필드<br>
```
- NAME : 찾고자 하는 가변 길이의 도메인 이름
- TYPE : 16비트 크기로 자원의 종류
- CLASS : 프로토콜 패밀리를 의미
- TTL : 자원 레코드가 만기까지의 유효 시간을 초 단위로 표시
- RD Length : 자원 데이터의 길이를 바이트 단위로 나타냄
- RD(자원 데이터) : 자원 레코드와 관계된 데이터가 기록
```
---
> 인증 데이터<br>
```
- 네임 서버가 하나면 이 서버가 DNS에 관한 정보를 관리
- 네임 서버의 부담을 줄이기 위하여 캐시 정보 활용
- 인증 데이터 : 해당 데이터를 직접 관리할 책임이 있는 네임 서버로부터 받은 정보
- 캐시 데이터 : 이전 요청에 의하여 호스트가 보관하던 정보
- 캐시 데이터를 오해 보관하면 클라이언ㅌ트에 다른 정보를 전달할 염려가 있음
- 해당 정보의 인증 서버가 TTL 이라는 정보를 제공하여 초과된 정보는 자동으로 무효 처리하고 인증 서버에 다시 정보를 요청해서 캐시 데이터를 갱신함
```
---
> 존<br>
- 자원 레코드에 포함된 인증 데이터의 집합체로 정의됨
---
> 포함하는 영역<br>
```
- 존에 속하는 모든 호스트의 전체 자원 레코드 집합체
- 존에 포함된 최상위 호스트
- 위임 서브 존 : 자신의 존에 속하지만 인증이 위임된 경우
- 위임된 서버 존에 관한 글루 데이터 : 서브 존의 네임 서버에 접근할 수 있도록 해줌
```
---
> UDP의 제한<br>
```
- 해석기와 네임 서버는 UDP 53번 포트로 DNS 메시지 전송
- DNS 메시지가 512바이트보다 크면 TCP를 사용하는데 이때도 DNS 메시지 전송은 53번 포트를 사용함
- ZONE 파일을 전송시에 TCP를 사용
```
---
> MIME<br>
```
- ASCII 기반의 메시지 형식을 그대로 유지
- 메시지 내용에 멀티미디어 데이터 인코딩 방법을 추가로 정의하여 멍티미디어 데이터를 수용가능하게 확장함
```
---
> SMTP<br>
```
- 전자 메일의 전송은 SMTP 프로토콜을 지우너하는 호스트 사이에 이루어짐
- Well-known 포트 : TCP 25번
- 메시지 다운로드 과정에서 사용자 인증 허가가 반드시 필요
```
---
> POP<br>
```
- SMTP와 별도로 SMTP 서버와 PC/스마트폰을 연동
- Well-known 포트 : TCP 110번
- 메인 송수신 과정에서 사용자 인증 허가 불필요
```






























