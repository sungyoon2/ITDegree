# 시스템 프로그래밍 정리
> CPU<br>
- ALU
```
연산 -> execution
```
- 컨트롤유닛
```
명령어 저장, 처리해야할 명령어 해석 -> decode
```
- 레지스터
```
임시저장
```
- 버스 인터페이스
```
통로 -> fetch(메모리상에 존재하는 명령어를 cpu로 가져오는 작업)
```
---
> 클럭신호<br>
- CPU가 일할때 CPU구성요소들에 제공되는 신호 -> 동기화에 이용
---
> 시스템 프로그래밍<br>
- 하드웨어와 운영체제로 구성
- 시스템은 활용하는 소프트웨어 개발에 사용
- 모든 응용 프로그램에 포함되는 요소
cf) 연산이 이루어지는 원리는 cpu
---
> 전처리기에 의한 치환작업<br>
- #으로 시작하는 지시자
---
> 프로그램 실행과정<br>
```
1. 전처리기
2. 컴파일러(자연어를 cpu명령어로 치환)
3. 어셈블러(cpu명령어를 바이너리 코드로 번역)
4. 링커
5. loader or 실행파일
```
---
> CPU와 메모리간의 정보를 주고 받는 버스<br>
- 주소버스
- 데이터 버스
- 컨트롤 버스
---
> 아스키 코드<br>
- 미국에서 정의하고 있는 표준
- 256개의 문자
- 문자당 1바이트 사용
---
> 유니코드<br>
- 전세계의 언어를 표현하기위해 사용
- 모든 문자당 2바이트 사용
---
> 문자셋 종류<br>
- SBCS
```
- ASCII코드
- 1 BYTE
```
- MBCS
```
- 영어는 1 BYTE, 나머지는 2 BYTE
```
- WBCS
```
- 유니코드
- 모든 문자 균일하게 2 BYTE
```
---
> 유니코드 방식과 MBCS 방식을 모두 지원하기 위한 MAIN함수의 구성<br>
- _tmain이 존재
---
> 매인 메모리와 CPU간 데이터<br>
```
- 입출력 버스를 통해 전달
- CPU 버스 인터페이스를 통해 레지스터에 저장
```
---
> 32비트와 64비트의 차이점<br>
```
1. 32비트
- 데이터를 4byte단위로 처리 및 통신
- 32비트 컴푸터에서 최대 ram의 크기는 4G바이트
2. 64비트
- 데이터를 8byte단위로 처리 및 통신
- 64비트 컴퓨터에서 최대 RAM의 크기는 16테라바이트
```
---
> 32bit와 64bit 운영체제 구분법<br>
- 한번에 송수신 가능한 데이터 크기 이용
---
> LLP64<br>
```
- Windows모델
- int와 Long=> 4byte표현
- Pointer만 8byte
- 32bit시스템과 호환성 중시
```
---
> 데이터 손실<br>
- 표현할 수 있는 범위를 벗어날 때 발생
---
> Polymorphic 자료형<br>
- 상황 & 환경에 따라 그 자료형이 의미하는 바가 유동적으로 변경
---
> Windows스타일의 자료형<br>
```
- 다른 시스템으로의 이식성 고려
- 프로젝트 성격 및 특성에 맞게 새로운 이름으로 자료형 정의
- typedef를 통한 복잡한 선언을 단순화
- 프로그램 전체에 적용된 내용변경시 easy
```
---
> 포인터에 대한 windows의 정의<br>
```
- Win32에 정의 된 자료형이 Win64필요 없는건 아님
- Win32와 Win64 서로 호환
- 유니코드, 아스키코드 모두 지원
```
---
> GetLastError함수<br>
- 오류원인을 확인하는 함수
---
> CreateFile함수<br>
```
- 파일을 open
- 실패시 Invlid_Handle_Value를 반환
```
---
> 레지스터<br>
- 모든 연산을 수행, 임시저장
---
> 레지스터 디자인을 위해 결정해야할 요소<br>
```
- 레지스터를 몇 비트로 구성할지
- 몇개 정도로 레지스터를 구성할지
- 레지스터 각각을 무슨 용도로 사용할지
```
---
> Indirect모드<br>
```
- 메모리에 저장된 값이 주소이므로, 다른 메모를 한번더 참조하여 값을 가져옴
=> 저장된 값의 주소가 범위를 벗어날 경우 생기는 문제를 해결하기 위해
```
---
> 프로그램 실행시 만들어지는 메모리 구조<br>
```
- Stack : 지역변수, 함수 호출시 전달되는 인자 값들의 저장을 위해 존재
- Heap : 동적 할당을 위해 존재
- Data : 전역 변수, static변수의 할당을 위해 존재
- Code : 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역
```
---
> 스케줄링<br>
- 하나의 cpu가 여러프로세스를 사용할 수 있도록 할당 순서 및 방법을 결정
---
> i/o 관련일 수행시 CPU의 상태<br>
- Ready
---
> 컨텍스트 스위칭<br>
- 실행할 프로세스가 바뀔때마다 레지스터의 값들도 바뀌는 현상 -> 시스템에 많은 부담
---
> CreateProcess 함수<br>
- 프로세스 생성과 프로세스간의 관계를 위해
```
(CreateProcess 함수의 인자>
- IpApplicatrionName : 생성할 프로세스의 실행파일이름을 인자로 전달
- IpCommandLine : 새로 생성하는 프로세스에 인자 전달 -> 두 번째 매개 변수 사용,
- IpProcessAttributes : 프로세스의 보안 속성 지정 인자 ->보통 null전달
- IpThreadAttributes : 스레드의 보안 속성 지정
- hInheritHandle : 전달 인자가 True인 경우 생성되는 자식 프로세스는 부모 프로세스가 소유하는 핸들중 일부를 상속
- dwCreatonFlag : 생성하는 프로세스의 특성을 결정하는 옵션
- IpEnvironment : 프로세스마다 환경 블록이라는 메모리 블록관리, 실행에 필요로 하는 문자열 저장
- IpCurrentDirectory : 현재 디렉터리 설정
- IpStartupInfo : StartupInfo 구조체 변수를 초기화, 이 변수의 포인터를 인자로 전달, 속성을 지정할 때 사용
- IpProcessInformation : 생성하는 프로세스 정보 획득을 위한 인자
```
---
> 프로세스 종료시<br>
```
- Usage count가 감소
- 커널오브젝트는 소멸X, 존재
- Closehandle함수 호출 -> 커널오브젝트 소멸가능
```
---
> 커널오브젝트<br>
```
- 커널에서 관리하는 중요한 정보들을 담아둔 데이터 블록
- 프로세스에 종속적 X
- 생성과 소멸은 운영체제에 의해서 결정
- 운영체제에 종속적인 관계 -> 여러프로세스에 의해 접근 가능
- 프로세스가 소멸된다고 커널오브젝트가 소멸은 X
```
---
> 파일 커널 오브젝트<br>
- 파일 속성을 저장
---
> 프로세스 커널 오브젝트<br>
- 프로세스 우선순위를 저장
---
> 운영체제<br>
```
- 프로세스를 생성하는 실질적 주체
- 프로세스의 상태정보, 우선순위정보를 저장
```
---
> 자식프로세스의 종료코드<br>
- 자식커널오브젝트에 저장됨 -> 부모 커널오브젝트에 저장되는 것은 아님
---
> 'Close Handle' 함수<br>
- 커널 오브젝트를 소멸시키기 위해 호출하는 함수
---
> 커널오브젝트 소멸시기<br>
```
- 참조하는 대상이 없을때
- Usage count값이 0일때
```
---
> Terminat process<br>
- 프로세스 상태와 무관하게 강제종료
---
> 프로세스의 통신<br>
- 공유공간이 있어야만 가능
---
> 메일 슬롯<br>
```
- 공유메모리의 입구를 의미
- 선형적 메모리 구조
- 브로드 캐스팅 방식
- Receiver와 Sender가 데이터를 주고 받기위해선 공유 메몰리와 주소값이 필요
- 단방향 전송이기에, 양방향 전송을 위해선 메일슬롯 2개가 필요
- 프로세스와 스레드를 제외한 모든 커널오브젝트는 생성과 동시에 Usage count = 1
- 자식프로세스는 Usage count = 2
```
---
> 메일슬롯 구성<br>
```
- Receiver 프로세스 : 공유메모리 준비
- Sender 프로세스 : 주소를 알고 있어야 함
```
---
> IPC<br>
```
- 둘이상의 프로세스가 데이터를 주고받는 행위
- 선형적 메모리 구조의 특성
- 두 프로세스가 공유 메모리를 통해 통신 가능
- 두 프로세스의 통신을 위해선 공유메모리와 주소 필요
```
---
> 커널오브젝트 상태<br>
```
- 프로세스가 생성될 때 만들어짐
- 리소스의 현재상태를 알기위한 상태
<현재 상태>
- Signaled : 프로세스 커널오브젝트 종료
- Non-signaled : 프로세스 커널오브젝트 생성(진행중)
```
---
> 핸들테이블<br>
```
- 핸들 정보를 저장하고 있는 테이블
- 프로세스 별로 독립적
- 커널오브젝트가 생성되고, 최종적으로 커널오브젝트의 핸들이 반환됨.
- 핸들은 메일 슬롯의 커널오브젝트를 가리키는 용도
```
---
> 메일슬롯 생성순서<br>
```
1. 메일슬롯리소스 생성
2. 커널 오브젝트 생성
3. 핸들정보가 핸들케이들에 갱신
4. 핸들값 반환
```
---
> 이름있는 파이프<br>
```
- 주소정보를 통해 정보를 교환
- 메일 슬롯과 유사
- 관계없는 프로세스들 가이에 통신하는 경우 사용
- 양방향 통신
- 브로드 캐스트 지원X
```
---
> 이름 없는 파이프<br>
```
- 파이프를 통해 생성된 핸들을 기반으로 통신
- 관계가 있는 프로세스들 사이에 통신하는 경우 사용
- 단방향 통신만 지원
```
---
> 메일슬롯<br>
```
- 단방향 통신
- 브로드캐스팅방식 지원
```
---
> 부모프로세스는 자식 프로세스 생성시 환경변수도 상속가능<br>
---
> 파이프 방식의 IPC에서 dwPipeMode<br>
- 설정값들이 OR연산되어 전달
---
> 프로세스의 환경변수의 구성<br>
```
- 프로세스별 별도의 메모리 공간을 사용
- 문자열 데이터를 저장하고 관리
- 자식프로세스의 환경변수 등록이 가능
```
---
> 일반 OS<br>
```
- 사용하는 영역이 범용
- 사용자가 시키는 일이외에 일이 많음
```
---
> 리얼타임 OS<br>
- 일반 os와의 차이는 응답성(응답속도), 명령어 신속처리
```
- 사용하는 영역이 제한적
- 사용자가 시키는 작업만 수행
- 내부 프로세스의 전력소모량을 최소화한다.
```
---
> 선점형 os<br>
```
- 우선순위가 높은 프로세스 등장시 스케줄러에 의해 실행순서가 조정
- 스케줄러가 적절히 시간을 배분
```
---
> 비선점형 os<br>
```
- 우선순위가 높은 프로세스가 등장한다고 해도 실행의 대상은 바로 변경 X
- 현재 실행중인 프로세스가 양보해야함
- IO작업등으로 블로킹 상태에 놓일 때 까지 대기
```
---
> 스케줄링 알고리즘의 진행시점<br>
```
- 라운드 로빈 방식의 스케줄링 알고리즘 적용
- 우선순위 방식의 스케줄링 알고리즘 적용
- 블로킹 상황
```
---
> Priority inversion의 개발자 고려사항<br>
```
- 프로세스의 우선순위의 뒤바뀜
- 우선순위 위임
```































