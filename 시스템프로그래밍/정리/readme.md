# 시스템 프로그래밍 정리
> CPU<br>
- ALU
```
연산 -> execution
```
- 컨트롤유닛
```
명령어 저장, 처리해야할 명령어 해석 -> decode
```
- 레지스터
```
임시저장
```
- 버스 인터페이스
```
통로 -> fetch(메모리상에 존재하는 명령어를 cpu로 가져오는 작업)
```
---
> 클럭신호<br>
- CPU가 일할때 CPU구성요소들에 제공되는 신호 -> 동기화에 이용
---
> 시스템 프로그래밍<br>
- 하드웨어와 운영체제로 구성
- 시스템은 활용하는 소프트웨어 개발에 사용
- 모든 응용 프로그램에 포함되는 요소
cf) 연산이 이루어지는 원리는 cpu
---
> 전처리기에 의한 치환작업<br>
- #으로 시작하는 지시자
---
> 프로그램 실행과정<br>
```
1. 전처리기
2. 컴파일러(자연어를 cpu명령어로 치환)
3. 어셈블러(cpu명령어를 바이너리 코드로 번역)
4. 링커
5. loader or 실행파일
```
---
> CPU와 메모리간의 정보를 주고 받는 버스<br>
- 주소버스
- 데이터 버스
- 컨트롤 버스
---
> 아스키 코드<br>
- 미국에서 정의하고 있는 표준
- 256개의 문자
- 문자당 1바이트 사용
---
> 유니코드<br>
- 전세계의 언어를 표현하기위해 사용
- 모든 문자당 2바이트 사용
---
> 문자셋 종류<br>
- SBCS
```
- ASCII코드
- 1 BYTE
```
- MBCS
```
- 영어는 1 BYTE, 나머지는 2 BYTE
```
- WBCS
```
- 유니코드
- 모든 문자 균일하게 2 BYTE
```
---
> 유니코드 방식과 MBCS 방식을 모두 지원하기 위한 MAIN함수의 구성<br>
- _tmain이 존재
---
> 매인 메모리와 CPU간 데이터<br>
```
- 입출력 버스를 통해 전달
- CPU 버스 인터페이스를 통해 레지스터에 저장
```
---
> 32비트와 64비트의 차이점<br>
```
1. 32비트
- 데이터를 4byte단위로 처리 및 통신
- 32비트 컴푸터에서 최대 ram의 크기는 4G바이트
2. 64비트
- 데이터를 8byte단위로 처리 및 통신
- 64비트 컴퓨터에서 최대 RAM의 크기는 16테라바이트
```
---
> 32bit와 64bit 운영체제 구분법<br>
- 한번에 송수신 가능한 데이터 크기 이용
---
> LLP64<br>
```
- Windows모델
- int와 Long=> 4byte표현
- Pointer만 8byte
- 32bit시스템과 호환성 중시
```
---
> 데이터 손실<br>
- 표현할 수 있는 범위를 벗어날 때 발생
---
> Polymorphic 자료형<br>
- 상황 & 환경에 따라 그 자료형이 의미하는 바가 유동적으로 변경
---
> Windows스타일의 자료형<br>
```
- 다른 시스템으로의 이식성 고려
- 프로젝트 성격 및 특성에 맞게 새로운 이름으로 자료형 정의
- typedef를 통한 복잡한 선언을 단순화
- 프로그램 전체에 적용된 내용변경시 easy
```
---
> 포인터에 대한 windows의 정의<br>
```
- Win32에 정의 된 자료형이 Win64필요 없는건 아님
- Win32와 Win64 서로 호환
- 유니코드, 아스키코드 모두 지원
```
---
> GetLastError함수<br>
- 오류원인을 확인하는 함수
---
> CreateFile함수<br>
```
- 파일을 open
- 실패시 Invlid_Handle_Value를 반환
```
---
> 레지스터<br>
- 모든 연산을 수행, 임시저장
---
> 레지스터 디자인을 위해 결정해야할 요소<br>
```
- 레지스터를 몇 비트로 구성할지
- 몇개 정도로 레지스터를 구성할지
- 레지스터 각각을 무슨 용도로 사용할지
```
---
> Indirect모드<br>
```
- 메모리에 저장된 값이 주소이므로, 다른 메모를 한번더 참조하여 값을 가져옴
=> 저장된 값의 주소가 범위를 벗어날 경우 생기는 문제를 해결하기 위해
```
---
> 프로그램 실행시 만들어지는 메모리 구조<br>
```
- Stack : 지역변수, 함수 호출시 전달되는 인자 값들의 저장을 위해 존재
- Heap : 동적 할당을 위해 존재
- Data : 전역 변수, static변수의 할당을 위해 존재
- Code : 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역
```
---
> 스케줄링<br>
- 하나의 cpu가 여러프로세스를 사용할 수 있도록 할당 순서 및 방법을 결정
---
> i/o 관련일 수행시 CPU의 상태<br>
- Ready
---
> 컨텍스트 스위칭<br>
- 실행할 프로세스가 바뀔때마다 레지스터의 값들도 바뀌는 현상 -> 시스템에 많은 부담
---
> CreateProcess 함수<br>
- 프로세스 생성과 프로세스간의 관계를 위해
```
(CreateProcess 함수의 인자>
- IpApplicatrionName : 생성할 프로세스의 실행파일이름을 인자로 전달
- IpCommandLine : 새로 생성하는 프로세스에 인자 전달 -> 두 번째 매개 변수 사용,
- IpProcessAttributes : 프로세스의 보안 속성 지정 인자 ->보통 null전달
- IpThreadAttributes : 스레드의 보안 속성 지정
- hInheritHandle : 전달 인자가 True인 경우 생성되는 자식 프로세스는 부모 프로세스가 소유하는 핸들중 일부를 상속
- dwCreatonFlag : 생성하는 프로세스의 특성을 결정하는 옵션
- IpEnvironment : 프로세스마다 환경 블록이라는 메모리 블록관리, 실행에 필요로 하는 문자열 저장
- IpCurrentDirectory : 현재 디렉터리 설정
- IpStartupInfo : StartupInfo 구조체 변수를 초기화, 이 변수의 포인터를 인자로 전달, 속성을 지정할 때 사용
- IpProcessInformation : 생성하는 프로세스 정보 획득을 위한 인자
```
---
> 프로세스 종료시<br>
```
- Usage count가 감소
- 커널오브젝트는 소멸X, 존재
- Closehandle함수 호출 -> 커널오브젝트 소멸가능
```
---
> 커널오브젝트<br>
```
- 커널에서 관리하는 중요한 정보들을 담아둔 데이터 블록
- 프로세스에 종속적 X
- 생성과 소멸은 운영체제에 의해서 결정
- 운영체제에 종속적인 관계 -> 여러프로세스에 의해 접근 가능
- 프로세스가 소멸된다고 커널오브젝트가 소멸은 X
```
---
> 파일 커널 오브젝트<br>
- 파일 속성을 저장
---
> 프로세스 커널 오브젝트<br>
- 프로세스 우선순위를 저장
---
> 운영체제<br>
```
- 프로세스를 생성하는 실질적 주체
- 프로세스의 상태정보, 우선순위정보를 저장
```
---
> 자식프로세스의 종료코드<br>
- 자식커널오브젝트에 저장됨 -> 부모 커널오브젝트에 저장되는 것은 아님
---
> 'Close Handle' 함수<br>
- 커널 오브젝트를 소멸시키기 위해 호출하는 함수
---
> 커널오브젝트 소멸시기<br>
```
- 참조하는 대상이 없을때
- Usage count값이 0일때
```
---
> Terminat process<br>
- 프로세스 상태와 무관하게 강제종료
---
> 프로세스의 통신<br>
- 공유공간이 있어야만 가능
---
> 메일 슬롯<br>
```
- 공유메모리의 입구를 의미
- 선형적 메모리 구조
- 브로드 캐스팅 방식
- Receiver와 Sender가 데이터를 주고 받기위해선 공유 메몰리와 주소값이 필요
- 단방향 전송이기에, 양방향 전송을 위해선 메일슬롯 2개가 필요
- 프로세스와 스레드를 제외한 모든 커널오브젝트는 생성과 동시에 Usage count = 1
- 자식프로세스는 Usage count = 2
```
---
> 메일슬롯 구성<br>
```
- Receiver 프로세스 : 공유메모리 준비
- Sender 프로세스 : 주소를 알고 있어야 함
```
---
> IPC<br>
```
- 둘이상의 프로세스가 데이터를 주고받는 행위
- 선형적 메모리 구조의 특성
- 두 프로세스가 공유 메모리를 통해 통신 가능
- 두 프로세스의 통신을 위해선 공유메모리와 주소 필요
```
---
> 커널오브젝트 상태<br>
```
- 프로세스가 생성될 때 만들어짐
- 리소스의 현재상태를 알기위한 상태
<현재 상태>
- Signaled : 프로세스 커널오브젝트 종료
- Non-signaled : 프로세스 커널오브젝트 생성(진행중)
```
---
> 핸들테이블<br>
```
- 핸들 정보를 저장하고 있는 테이블
- 프로세스 별로 독립적
- 커널오브젝트가 생성되고, 최종적으로 커널오브젝트의 핸들이 반환됨.
- 핸들은 메일 슬롯의 커널오브젝트를 가리키는 용도
```
---
> 메일슬롯 생성순서<br>
```
1. 메일슬롯리소스 생성
2. 커널 오브젝트 생성
3. 핸들정보가 핸들케이들에 갱신
4. 핸들값 반환
```
---
> 이름있는 파이프<br>
```
- 주소정보를 통해 정보를 교환
- 메일 슬롯과 유사
- 관계없는 프로세스들 가이에 통신하는 경우 사용
- 양방향 통신
- 브로드 캐스트 지원X
```
---
> 이름 없는 파이프<br>
```
- 파이프를 통해 생성된 핸들을 기반으로 통신
- 관계가 있는 프로세스들 사이에 통신하는 경우 사용
- 단방향 통신만 지원
```
---
> 메일슬롯<br>
```
- 단방향 통신
- 브로드캐스팅방식 지원
```
---
> 부모프로세스는 자식 프로세스 생성시 환경변수도 상속가능<br>
---
> 파이프 방식의 IPC에서 dwPipeMode<br>
- 설정값들이 OR연산되어 전달
---
> 프로세스의 환경변수의 구성<br>
```
- 프로세스별 별도의 메모리 공간을 사용
- 문자열 데이터를 저장하고 관리
- 자식프로세스의 환경변수 등록이 가능
```
---
> 일반 OS<br>
```
- 사용하는 영역이 범용
- 사용자가 시키는 일이외에 일이 많음
```
---
> 리얼타임 OS<br>
- 일반 os와의 차이는 응답성(응답속도), 명령어 신속처리
```
- 사용하는 영역이 제한적
- 사용자가 시키는 작업만 수행
- 내부 프로세스의 전력소모량을 최소화한다.
```
---
> 선점형 os<br>
```
- 우선순위가 높은 프로세스 등장시 스케줄러에 의해 실행순서가 조정
- 스케줄러가 적절히 시간을 배분
```
---
> 비선점형 os<br>
```
- 우선순위가 높은 프로세스가 등장한다고 해도 실행의 대상은 바로 변경 X
- 현재 실행중인 프로세스가 양보해야함
- IO작업등으로 블로킹 상태에 놓일 때 까지 대기
```
---
> 스케줄링 알고리즘의 진행시점<br>
```
- 라운드 로빈 방식의 스케줄링 알고리즘 적용
- 우선순위 방식의 스케줄링 알고리즘 적용
- 블로킹 상황
```
---
> Priority inversion의 개발자 고려사항<br>
```
- 프로세스의 우선순위의 뒤바뀜
- 우선순위 위임
```
--- 
> 스택<br>
```
- 함수 호출 과정에서 할당되는 메모리 블록
- POP & Push 명령어를 사용해 연산
* pop&push : SP가 가리키는 현재 위치에 전달되는 인자값을 저장하고 나서, SP를 증가시켜 다은 메모리 주소를 가리키게 한다
```
---
> 함수와 프로시저<br>
```
- 함수 : 입력에 대한 출력 반환값이 존재
- 프로시저 : 반환값 없음
```
---
> sp레지스터<br>
```
<개요>
  - 스택위치 기억을 위해 CPU내에 존재하는 레지스터
  - 함수 호출시 SP레지스터 값이 증가
  - 함수 종료시 선언된 변수를 반환
<문제점>
- 얼마나 sp를 이동시켜야 할지 모름
- 프레임 포인터 reg가 필요
```
---
> fp레지스터<br>
```
<개요>
  - 함수 호출시 0으로 초기화되며, 변수 선언시 스 크기만큼 증가
  - 정수형 변수 선언 시 4씩 증가
<문제점>
  - 변수를 선언할 때마다 덧셈 연산 수행
  - 스택 연산 증가
  - 함수호출이 중첩될 경우 문제 발생
  - fp 레지스터에 저장되는 값 덮어쓰기기
```
---
> 함수호출인자 전달방식<br>
```
- 함수 호출방식은 입력에 대한 출력반환 값이 반드시 존재
- 전달인자들이 반드시 스택할당은 X
```
> 명령어 실행의 3단계<br>
```
- fetch
- decode
- excution
```
---
> 프로그램 카운터<br>
- 함수 호출시 특정 위치로의 이동시 활용
---
> pc레지스터<br>
```
- 다음에 실행할 명령어를 가져올 수 있다
- 자동으로 값이 증가
- 명령어를 순차적으로 실행하기 위해 사용
- 필요에 따라 프로그램상에서 직접 조절이 가능
**이동 주소값 저장시 유의사항**
- 현재 pc값 백업 필수
- pc값이 없을 경우 완료된 이후 돌아갈 위치를 찾을 수 없음
```
---
> _fastcall함수 규약<br>
```
- 함수 호출를 빠를게 처리하기 위한 규약
- 레지스터의 매개 변수 부분의 전달되는 인자를 저장할 때 레지스터 사용유무를 설명
- 가장 중요한 것은 레지스터를 사용하고 있다는 것
- 두개의 전달인자는 레지스터 exc와 edx를 통해 저장
```
---
> 쓰레드<br>
```
- cpu이용량 딘위의 기본
- 쓰레드마다 PCB가 존재
- 프로세스내에서의 제어흐름
- 같은 프로세스에 속한 각 쓰레드는 공유 가능
```
---
> 컨텍스트 스위칭<br>
```
- 프로세스의 상태정보를 저장 & 복원
- 초당 수십회 이상 발생
```
---
> 컨텍스트 스위칭 문제 해결방안<br>
```
- 저장하고 복원하는 컨텍스트 정보 최소화
- 프로세스의 상태 정보를 최소화
```
---
> 멀티 프로세스 운영체제 기반 프로그램의 문제점<br>
- 멀티 프로세스에서 프로세스 생성은 빈번한 컨텍스트 스위칭 발생 -> 성능저하의 원인이 됨
---
> 프로세스와 쓰레드<br>
```
- 프로세스 : 완전히 독립된 두개의 프로그램 실행을 위한 것
- 쓰레드 : 하나의 프로그램 내에서 둘 이상의 프로그램 흐름을 만들기 위해 디자인됨
```
---
> window운영체제 동작<br>
```
- 커널 모드: 문제발생시 시스템 전체에 영향
- 유저 모드: 실행중인 프로그램에만 영향향
```
---
> 쓰레드 함수<br>
```
- createThread : 쓰레드 생성함수
- dwStackSiza : 스택이 별도로 생성, 쓰레드 크기 지정
- IpthreadAttributes : 핸들의 상속여부 결정
- IpStartAddress : 쓰레드 동작하기 위한 함수
- IpParameter : 쓰레드 함수에 전달할 인자를 지정
- dwcreationFlags : 쓰레드의 생성 및 실행을 조정하기 위해 사용
- IpThreadid : 쓰레드 ID를 전달받기 우한 변수의 주소값 전달달
- return 문 : 쓰레드 소멸방법으로 이상적
- ExitThread함수 : 특정위치에서 실행종료
- Terminate Thread함수 : 외부에서 쓰레드 종료
```
---
> 쓰레드의 상태 변환<br>
```
- ready
- running
- block
```
---
> 프로세스<br>
```
- 쓰레드를 담는 상자역할
- 핸들테이블은 프로세스가 소유
- 실행 주체가 아님
```
---
> 쓰레드의 생성<br>
```
- 생성과 동시에 Usage count = 2
- 모든 쓰레드는 스택외에 모든것을 공유
- 종료시 Usage count값 감소
- closehandle함수 호출시 Usage count갑소 & 쓰레드가 독립됨
```
---
> 쓰레드의 동기화<br>
```
- 실행순서 동기화 : 반드시 순서를 지켜야 정확한 실행결과를 얻을 수 있음
- 메모리 접근에 대한 동기화 : 실행 순서 필요 x, 동시접근에 대한 문제 발생
```
---
> 쓰레드 우선순위<br>
```
- window에서 프로세스는 우선순위 X, 실행 주체도 X
- 프로세스의 기준 우선순위와 상대적 우선순위의 조합으로 결정
-
```
---
> Window에서 제공하는 동기화<br>
```
- 유저모드 : 동기화가 진행되는 동안 커널의 힘을 빌리지 않음, 커널코드 실행x, 즉, 커널 모드로의 전환 불필요 -> 성능상에 이점, 기능상의 제한 
- 커널모드: 커널에서 제공하는 동기화 기능 활용, 호출될때마다 커널 모드로의 변경이 필요, 성능의 저하, 유저 모드 동기화에서 제공하지못하는 기능 제공가능
```
---
> 임계영역에 대한 이해<br>
-
---
> 유저모드 동기화 방법<br>
```
- 크리티컬 세션 기반의 동기화 :
- 인터락 함수 기반의 동기화 : 함수 내부적으로 한 순간에 하나의 쓰레드에 의해서만 실행되는 동기화, 크리티컬 섹션 동기화기법도 내부적으로는 인터락 함수를 기반으로 구현됨
```
---
> 커널모드 동기화 방법<br>
```
- 뮤텍스 기반 동기화
- 세마포어기반의 동기화
- 이름있는 뮤텍스 기잔의 프로세스 동기화
- 이벤트 동기화
```
---
> 뮤텍스<br>
- 세마포어중 단순화된 세마포어
---
> 뮤텍스의 상태<br>
```
- Non-Signaled : 뮤텍스를 획득한 상태
- Signaled : 뮤텍스x, 즉, 누군가에 의해 획득이 가능한 상태
```
---
> 뮤텍스 동기화와 세마포어 동기화의 차이<br>
```
- 뮤텍스 동기화 : 카운트 기능없음
- 세마포어동기화 : 카운트 기능(임계영역에 접근가능한 쓰에드 개수를 조절하는 기능)이 있음
```
---
> 이름있는 뮤텍스<br>
```
- 뮤텍스에 이름을 붙여 생성하는 경우 -> 뮤텍스는 운영체제를 소유
- 프로세스 A에 의해 생성, 프로세스 B에서 접근 가능 => 커널이 관리하는 오브젝트이기에 -> openmutex임
```
---
> 동기화가 필요한 이유<br>
- 메모리에 접근하는 쓰레드는 실행순서가 일정하지 않기때문
---
> 입출력 속도 차이 문제<br>
```
- 입력되는 양이 많은 경우 쓰레드가 감당하지 못하므로 문자열이 소멸하는 현상
(해결방법)
 - 버퍼를 두고 두개의 쓰레드가 입출력 속도에 상관없이 독립적으로 실행하도록 한다(각각 입력담당, 출력담당)
```
---
> closehandle<br>
- 이벤트 오브젝ㅇ트 소멸을 위해 사용되는 함수
---
> 이벤트 동기화 기법<br>
```
- 쓰레드의 실행순서 동기화에 사용
- 수동 리셋 : 블로킹된 함수 호출을 빠져나올 경우 자동으로 Non-signaled 상태로 변겨외지 않으므로 수동으로 변경
- 자동 리셋 : non-signaled 상태로의 변경은 자동을 이루어진다.
```




























