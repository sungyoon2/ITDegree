# 시스템 프로그래밍 정리
> CPU<br>
- ALU
```
연산 -> execution
```
- 컨트롤유닛
```
명령어 저장, 처리해야할 명령어 해석 -> decode
```
- 레지스터
```
임시저장
```
- 버스 인터페이스
```
통로 -> fetch(메모리상에 존재하는 명령어를 cpu로 가져오는 작업)
```
---
> 클럭신호<br>
- CPU가 일할때 CPU구성요소들에 제공되는 신호 -> 동기화에 이용
---
> 시스템 프로그래밍<br>
- 하드웨어와 운영체제로 구성
- 시스템은 활용하는 소프트웨어 개발에 사용
- 모든 응용 프로그램에 포함되는 요소
cf) 연산이 이루어지는 원리는 cpu
---
> 전처리기에 의한 치환작업<br>
- #으로 시작하는 지시자
---
> 프로그램 실행과정<br>
```
1. 전처리기
2. 컴파일러(자연어를 cpu명령어로 치환)
3. 어셈블러(cpu명령어를 바이너리 코드로 번역)
4. 링커
5. loader or 실행파일
```
---
> CPU와 메모리간의 정보를 주고 받는 버스<br>
- 주소버스
- 데이터 버스
- 컨트롤 버스
---
> 아스키 코드<br>
- 미국에서 정의하고 있는 표준
- 256개의 문자
- 문자당 1바이트 사용
---
> 유니코드<br>
- 전세계의 언어를 표현하기위해 사용
- 모든 문자당 2바이트 사용
---
> 문자셋 종류<br>
- SBCS
```
- ASCII코드
- 1 BYTE
```
- MBCS
```
- 영어는 1 BYTE, 나머지는 2 BYTE
```
- WBCS
```
- 유니코드
- 모든 문자 균일하게 2 BYTE
```
---
> 유니코드 방식과 MBCS 방식을 모두 지원하기 위한 MAIN함수의 구성<br>
- _tmain이 존재
---
> 매인 메모리와 CPU간 데이터<br>
```
- 입출력 버스를 통해 전달
- CPU 버스 인터페이스를 통해 레지스터에 저장
```
---
> 32비트와 64비트의 차이점<br>
```
1. 32비트
- 데이터를 4byte단위로 처리 및 통신
- 32비트 컴푸터에서 최대 ram의 크기는 4G바이트
2. 64비트
- 데이터를 8byte단위로 처리 및 통신
- 64비트 컴퓨터에서 최대 RAM의 크기는 16테라바이트
```
---
> 32bit와 64bit 운영체제 구분법<br>
- 한번에 송수신 가능한 데이터 크기 이용
---
> LLP64<br>
```
- Windows모델
- int와 Long=> 4byte표현
- Pointer만 8byte
- 32bit시스템과 호환성 중시
```
---
> 데이터 손실<br>
- 표현할 수 있는 범위를 벗어날 때 발생
---
> Polymorphic 자료형<br>
- 상황 & 환경에 따라 그 자료형이 의미하는 바가 유동적으로 변경
---
> Windows스타일의 자료형<br>
```
- 다른 시스템으로의 이식성 고려
- 프로젝트 성격 및 특성에 맞게 새로운 이름으로 자료형 정의
- typedef를 통한 복잡한 선언을 단순화
- 프로그램 전체에 적용된 내용변경시 easy
```
---
> 포인터에 대한 windows의 정의<br>
```
- Win32에 정의 된 자료형이 Win64필요 없는건 아님
- Win32와 Win64 서로 호환
- 유니코드, 아스키코드 모두 지원
```
---
> GetLastError함수<br>
- 오류원인을 확인하는 함수
---
> CreateFile함수<br>
```
- 파일을 open
- 실패시 Invlid_Handle_Value를 반환
```
---
> 레지스터<br>
- 모든 연산을 수행, 임시저장
---
> 레지스터 디자인을 위해 결정해야할 요소<br>
```
- 레지스터를 몇 비트로 구성할지
- 몇개 정도로 레지스터를 구성할지
- 레지스터 각각을 무슨 용도로 사용할지
```
---
> Indirect모드<br>
```
- 메모리에 저장된 값이 주소이므로, 다른 메모를 한번더 참조하여 값을 가져옴
=> 저장된 값의 주소가 범위를 벗어날 경우 생기는 문제를 해결하기 위해
```
---
> 프로그램 실행시 만들어지는 메모리 구조<br>
```
- Stack : 지역변수, 함수 호출시 전달되는 인자 값들의 저장을 위해 존재
- Heap : 동적 할당을 위해 존재
- Data : 전역 변수, static변수의 할당을 위해 존재
- Code : 실행 파일을 구성하는 명령어들이 올라가는 메모리 영역
```
---
> 스케줄링<br>
- 하나의 cpu가 여러프로세스를 사용할 수 있도록 할당 순서 및 방법을 결정
---
> i/o 관련일 수행시 CPU의 상태<br>
- Ready
---
> 컨텍스트 스위칭<br>
- 실행할 프로세스가 바뀔때마다 레지스터의 값들도 바뀌는 현상 -> 시스템에 많은 부담
---
> CreateProcess 함수<br>
- 프로세스 생성과 프로세스간의 관계를 위해
```
(CreateProcess 함수의 인자>
- IpApplicatrionName : 생성할 프로세스의 실행파일이름을 인자로 전달
- IpCommandLine : 새로 생성하는 프로세스에 인자 전달 -> 두 번째 매개 변수 사용,
- IpProcessAttributes : 프로세스의 보안 속성 지정 인자 ->보통 null전달
- IpThreadAttributes : 스레드의 보안 속성 지정
- hInheritHandle : 전달 인자가 True인 경우 생성되는 자식 프로세스는 부모 프로세스가 소유하는 핸들중 일부를 상속
- dwCreatonFlag : 생성하는 프로세스의 특성을 결정하는 옵션
- IpEnvironment : 프로세스마다 환경 블록이라는 메모리 블록관리, 실행에 필요로 하는 문자열 저장
- IpCurrentDirectory : 현재 디렉터리 설정
- IpStartupInfo : StartupInfo 구조체 변수를 초기화, 이 변수의 포인터를 인자로 전달, 속성을 지정할 때 사용
- IpProcessInformation : 생성하는 프로세스 정보 획득을 위한 인자




```
---
> 프로세스 종료시<br>
```
- Usage count가 감소
- 커널오브젝트는 소멸X, 존재
- Closehandle함수 호출 -> 커널오브젝트 소멸가능
```






























