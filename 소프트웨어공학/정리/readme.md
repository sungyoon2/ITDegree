# 소프트웨어 공학 정리
> 소프트웨어<br>
```
- 하드웨어를 이용하여 데이터를 처리하고 정보를 제공하여 여러응용 분야 업무를 자동화한다
- 컴퓨터를 작동시키는 program
- 하드웨어의 동작을 제어하는 수많은 명령어로 구성
```
---
> 소프트웨어 공학<br>
- 소프트웨어의 규모가 커질수록 프로그래밍보다 개발과정과 계획, 사용된 도구들이 생산성, 품질에 큰 영향을 미치기에 만들어진 공학
- 주된 목적은 주어진 비용과 자원안에서 품질 좋은 s/w를 기간내 생산
---
> 패키지형 소프트웨어<br>
- s/w에 대한 요구는 전적으로 시장 요구에 의해 결정
---
> 검증<br>
- 프로그램의 실행후 예상결과를 check, 실행전 원시코드를 인스펙션하여 요구사항과 일치하는지 확인하는 작업
---
> 품질 보증<br>
- 개발작업이 적절히 수행되었는지 확인
---
> 요구 분석<br>
- 소프트웨어 시스템이 해결 할 문제를 이해하기 위한 작업
---
> SWEBOK(Software Engneering Body of Knowledge)<br>
- 소프트웨어 개발분야의 엔지니어가 알아야할 지식체계를 공공성 있는 기관에서 누구나 동의할만큼 잘 정의
---
> 컴퓨터 과학<br>
- 계산적 효율, 자원 공유, 정확성, 성능 강조
- 개선을 위한 방법, 알고리즘, 원리, 기술을 다룸 => 정량적, 즉시 측정 가능
---
> 소프트웨어 공학<br>
- 생산성, 품질, 비용 시간을 목표로 개선하기 위함
---
> 소프트웨어 프로세스 모델<BR>
- 프로젝트의 작업공정을 구성하는 일반적인 접근방법
- 즉, 어떤 작업, 어떤 순서로 작업해야하는 지 결정하는데 도움
---
> 방법론<br>
- 이떤일을 하기 위한 방법으로 단계나 작업으로 구성됨
---
> 프로세스<br>
```
- 단계적 작업의 틀을 정의
- 무엇을 하는가에 중점
- 결과물이 표현에 대하여 언급x
- 패러다임에 대해 독립적
```
---
> 테스트<br>
```
- 개발자 또는 사용자 시각에 떄른 분류
- 사용되는 목적에 따른 분류
- 품질 특성에 따른 분류
```
---
> 소프트웨어 프로젝드<br>
```
- 설계가 끝나면 프로그램밍 작업에 들어감
- 설계 작업까지는 프로그램에 대한 언급x, 주로 기능과 외형(ui), 데아터베이스에 대해 설계
- 소프트웨어의 기능과 컴포넌트의 독립관계를 정확히 작성 후 프로그램 시작
- 소프트웨어 시스템을 구성하는 컴포넌트와 인터페이스에 대해 정의
```
---
> 소프트웨어 프로세스<br>
```
<개념>
- 프로젝트는 단계로 이루어짐
- 각 단계는 프로젝트 목표를 만족시킬수 있는 잘 정의된 작업으로 정의 되어야함
- 비용을 줄이기 위해 그 단계에 유입된 결함을 찾아내는데 초점
<특징>
- 입력과 결과물 즉, 진입조건과 출구조건, 결함을 찾기위한 검증작업 필요, 프로세스 관리를 위한 정보를 생성할 필요가 있음
```
---
> 결함제거 용이성<br>
```
- 개발과정의 모든 단계에서 오류가 발생가능함
- 오류를 발견하고 수정하는 소요되는  노력은 발생시점에 따라 다름
- 오류발생루 발견이 지연될수록 수정하는데 드는 비용이 늘어남
- 요구에 오류가 있다면 설계와 코드에 영향을 줌
```
---
> 프로토 타입 모델<br>
- 대량생산에 앞서서 미리 제작해보는 원형 또는 시제품
- 사용자와의 의사소통의 도구로 활용
---
> 나선형 모델<br>
- 소프트웨어 기능을 나누어 점증적 개발
- 여러번의 점증적인 릴리즈를 거침
---
> ISO/IEC12207<br>
```
- 소프트웨어 생명주기 프로세스 국제표준
- 시스템을 공급하려면 소프트웨어 개발 프로세스 뿐만아니라 문서와 형상관리,품질보증, 검사등의 지원 프로세스관리, 개선, 교육등의 조직 프로세스도 필요
```
---
> 프로젝트 관리 프로세스<br>
- 비용& 품질목표를 달성하기 위하여 관리하는 모든 작업
- 선택된 개발프로세스가 잘 구현 됬는지 확인하는 것
---
> 인스펙션 프로세스의 특성<br>
```
- 참석자의 역할이 정해진 process
- 전문기술인력이 담당
- 해결방법이 아닌 문제 자체에 집중
- 검토자료는 기록하며, 인스펙션 작업의 효율성을 모니터링하는데 사용
```
---
> 제어 분석<br>
- 모니터링에 의해 확인된 사실을 분석하고 계획과 치이나는 부분에 대하여 조정하고 조치하는 것
---
> 모니터링<br>
- 개발하는 동안 수행하는 모든 작업이 프로젝트의 목적과 부합되며, 개발이 계획대로 진척되는지 확인하기 위해 데이터를 수집하는 것
---
> 프로젝트<br>
- 정해진 기간안에 한정된 자원으로 일정한 목적을 달성하기 위해 수행하는 업무
---
> 프로젝트의 가치평가<br>
```
- 투자 회수 시간 : 투자금과 같은 금액을 벌어들이는 데 걸리는 시간
- ROI(Return of Investment) : 총비용에 대한 연간 평균 이익률
- 순수 현재 가치 : 현재 투자금과 미래 수익금을 현재 가치로 비교하는 방법
- 평가표 : 금액적인 요소 이외에 기술, 품질, 시간 여유, 인력 동을 고려하여 점수화하는 방법
- SWOT : 강점, 약점, 기회요인, 위협요인을 파악하여 타당성을 이해
```
---
> 타당성 분석 내용<br>
```
- SOW : 프로젝트가 성취해야 할 일
- 비즈니스 목표(가치) : 프로젝트의 결과물
- 예산 : 비용과 수익의 요약
- 프로젝트 일정 : 대략적인 일정
- 프로젝트 리스크 : 위험요소
- 대안 : 구축, 구매 등의 방법
- 평가
```
---
> 작업분할 구조도(WBS)<br>
```
- 사용자와 개발자간의 의사소통도구로 사용
- 프로젝트업무 내역을 가시화 할 수 있어 관리가 용이
- 프로젝트 팀원의 책임과 역할을 분명히 할 수 있음
- 필요 인력과 일정 계획을 세우는데 기초로 활용
- 개발비 산정시 기초로 활용
- 성과 측정 및 조정 시 기준선으로 활용
```
---
> 비용예측의 중요한 변수<br>
- 투입되는 엔지니어 인원수, 작업가간  => D = E/M(노력, 자원, 기간) 관계
---
> COCOMO초기 모델<br>
```
- 원시 프로그램규모에 의한 방법
- 먼저 완성될 시스템의 규모를 추정 -> 이를 준비된 식에 대압 -> 소요 M/M을 예측
```
---
> 기능점수<br>
```
- 정확한 라인수 예측 불가
- 입력, 출력, 질의, 파일, 인터페이스의 개수로 소프트웨어 규모 나타냄
- 각 기능에 가중값
- 가능점수 1을 구현하기 위한 LOC
```
---
> 기능 점수 산정의 특징<br>
```
(특징)
- 소프트웨어 규모를 측정하는 방법
- 기능적 요구 사항이 중심이 되는 측정법
- 소프트웨어의 요구사항 복잡도를 측정
- 구현 관점x(즉, 구현되는 언어에 상관없음), 사용자 관점의 요구기능을 정량적으로 산정
- 개발 규모를 예측하는데 적합
(단점)
- 모든 항목에 일률적인 가중치가 적용되므로 문제가 생길 수 있음
- 요구사항으로부터 기능을 도출하려면 상당한 분석능력 필요
- 이 방법으로 잘 사용할 수 있는 전문가가 필요
- 사용자가 알수 있는 기능으로 측정하기에  내부로직위주의 sw측정에는 부적합
```
---
> 모니터링의 목적<br>
```
- 프로젝트의 현황파악
- 차이를 분석하여 필요시 조치를 취하기 위함
```
---
> 일정을 모니터링하는 기본개념<br>
- 계획된 일정(주어진 시간계획의 스냅샷)을 기초로 실행값 비교
---
> 리스크 관리<br>
```
- 계획단계에는 목적달성을 위한 다양한 불확정성을 다루어야함
- 계획은 미리 명시되 있으나, 성취하기위한 현실은 변화와 부정적 요인이 많음
- 리스크 관리 => 위험요인 파악, 평가관리하는 기술과 노하우 프로세스를 의미
```
---
> 어닝벨류 분석<br>
```
- 기본적인 원리는 맨파워를 비용으로 봄
- 진척도를 노력으로 비교 가능
- 예산과 비용이 녹아있어 사용이 편리
- 과정은 복잡 but 전체적인 진척상황을 이해하기 쉬움
- 계획된 노력(비용), 실제 진척도(어닝벨류), 노력(실제비용)을 금전적 가치로 측정하여 통합된 모니터링 제공
```
---
> 번다운 차트<br>
```
- 애자일 프로세스 중 스크럽에서 수행된 작업보다 남아있는 작업에 초점을 두어 일정을 모니터링
- 스크럼에서 구현될 각 기능에 정상적인 투입시간을 할당
- 각 기능은 스프린트에 배정되어 기능의 완성되면 소멸되는 스프린트 점수로 기록
- 번다운 차트의 목표는 출시되는 속도를 측정하는 것
```
---
> 요구<br>
- 시스템이 무엇을 해야하고 어떤 특징을 가져야 하는지 명확히 정의
---
> 요구분석<br>
```
- 제품의 버전을 개발 & 프로젝트의 범위를 결정
- 추측결과는 분석으로, 분석 후 부족한 점 or 문제점은 다시 추출과정으로 피드백
- 무엇을(what)에 초점
- 응용영역의 지식으로부터 출발하여 문제를 찾아내고 새로운 시스템이 이를 해결하기 위한 동작 서비스를 찾아내어 정리하는 작업
```
---
> 요구분석 명세서<br>
```
- 다양한 이해관계자로부터 요구사항을 수집후 시스템 분석가가 작성한 문서
- 의도하는 소프트웨어가 사용자, 하드웨어, 외부시스템과 어떻게 상호작용하는지 정의 & 품질과 제한사항을 포함
- 고객으로부터 박은 요구사항은 먼저 자연어로 작성
- 시스템분석가는 요구사항을 모델릴언어로 문서화해 개발팀이 쉽게 이해하여 구현에 사용할 수 있게함
- 분석한 요구사항(제약조건, 성능에 관한 사항)을 빠짐없이 명확히 명기
- 요구분석과정의 최종 산물 -> 설계의 구현에서 참조할 사항, 전반적으로 알아야할 사항을 포함
```
- (개발자의 관점)
```
- 읽고 어떤 시스템이 개발될지 이해하는데 사용
- 기술된 기능적/비기능적 요구사항을 기반으로 분석, 설계, 코딩
- 개발완료후 구현의 점검항목으로 사용
- 사용자 지침용 초안 작성용으로 사용
```
---
> 기능요구<br>
```
- 시스템이 데이터나 인스트럭션에 대해 반응하는 동작이나 상태변화
- 입력자료가 제공되어 이를 변환처리하여 결과를 출력
- 시스템이 무엇을 하는지, 어떤 기능을 갖는지 기술하면 됨
- 성능이나 효율, 반응 시간, 제약 조건등은 기능 외적인 요구에 해당
```
---
> 비기능요구<br>
```
- 시스템 제공하는 기능에 직접 관련되지 않은 요구 -> 파생적으로 필요한 요구
- 시스템 구축에 필요한 성능, 보안, 품질, 안전등에 대한 요구사항
```
---
> 시나리오<br>
```
- 개발자와 사용자의 가장 큰 장벽인 서로 다른 전문영역의 용어에 대한 이해와 해석(용어와 개념을 전달하여 요구를 도출)
- 5W1H로 표현하면 효과적, when,who, what이 중요
```
---
> 도메인 분석<br>
```
- 요구의 배경을 알아보는 것을 의미
- 소프트웨어 구축시 문제가 무엇인지, 이해 & 문제를 해결하기위해 무엇이 요구되는지 알아야하며, 문제가 어디에 놓여있냐도 중요하기에 실행
- 소프트웨어 적용분야에 대해 깊은 이해는 없을시 -> 소프트웨어를 설계하는 것이 불가능
- 설계모델링에 필요한 여러개념과 비지니스 규칙을 파악하기 위함
```
---
> 요구분석에서 사용되는 시나리오의 흐름<br>
---
> 유스케이스 사이의 관계<br>
```
- 연관 : 해당 액터와 정보를 주고 받는 유스케이스와 설정
- 포함 : 하나의 유스케이스를 실행시, 같은 기능이 있는 다른 유스케이스가 반드시 수행되는 관계
- 확장 : 확장하는  유스케이스는 상위유스케이스로부터 어떠한 특정조건에 의해 실행
- 일반화: 액터들이 유스케이스와 중복하여 관계가 나타나면 액터들을 통합하여 중복된 부분이 있을 때 설정
- 중복 : 유스케이스 모델링시 유스케이스 이벤트 흐름에서 중복된 부분이 있을 때 설정
```
---
> 요구명세(SRS)<br>
```
- 프로젝트 산출물 중 가장 중요한 문서
- 개발 프로젝트에 대한 공통 목표 제시
- 대상 시스템이 무엇을 수행할 것 인가에 대해 기술
- 시스템이 이루어야할 목표를 기술, 달성하기 위한 해결방법을 기술하는 것은 아니다
```
---
> 요구검증<br>
```
- 사용자의 요구가 요구분석명세서에 올바르게 기술되었는지 검토
- 초기단계에서 매우 중요한 의미
- 발견 못할 시 구현 후 결함이 되며 추후 수정에 비용이 많이 듬
- 요구분석단계에서 발생하는 오류가 비율이 많음 => 오류 유입을 맏는 법 : 리뷰, 워크스루....
```
---
> UML<br>
```
- Unified Modeling Language
- 시스템 개발을 위한 시각적인 설계표기를 제공하는 것
- 시각화 언어 : 소프트웽어의 개념모델을 시각적인 형태로 표현하여 표준화된 다이어그램을 제공
```
---
> 요구모델링의 이유<br>
```
- 복잡함을 잘 관리하기위해
- 형체 X, 소프트웨어의 구조를 시각화하기 위해
- 다른 사람과 커뮤니케이션 하기 위해
- 문제 도메인 및 제품요구사항을 이해하기 위해
```
---
> UML모델링 과정<br>
```
1. 요구를 사용 사례로 정리하고 사용 사례 다이어그램을 작성
2. 클래스 후보를 찾아내고 개념적인 객체 모형을 작성
3. 사용 사례를 기초하여 순서 다이어그램을 작성
4. 클래스의 속성, 오퍼레이션 및 클래스 사이의 관계를 찾아 객체 모형을 완성
5. 상태 다이어그램이나 액티비티 다이어그램 등 다이어그램을 추가하여 UML 모델을 완성
6. 서브 시스템을 파악하고 전체 시스템 구조를 설계
7. 적당한 객체를 찾아내거나 커스텀화 또는 객체를 새로 설계
```
---
> UML이 제공하는 다이어그램<br>
```
- 유스케이스
- 클래스
- 순차
- 통신
- 활동
- 상태
- 컴포넌트
- 배치
- 패키지
```
---
> 객체지향<br>
- 자료구조를 중심으로 객체를 설계한 다음 이들의 흐름을 설계하는 방식
```
<기본요소>
- 객체
- 클래스
- 메세지 - 객체간의 상호 작용 수단
```
---
> 추상클래스<br>
```
- 클래스의 명칭과 메서드는 있으나 메서드 처리내용은 x
- 상속을 통해 메서드가 구현
- 추상 메서드외에 일반적인 속성과 메서드를 가질 수 있음
- 메서드의 다형성을 지원
```
---
> 링크<br>
```
- 통신다이어그램에서 객체사이를 연결
- 객체와 객체 간의 양방향 연관 관계
- 화살표 없는 실선으로 표현
- 이름 붙일 수 있음
```
---
> 동적모델링의 시퀸스 다이어그램<br>
```
- 순차 다이어그램
- 통신 다이어그램
- 상태 다이어그램
```
---
> 상태다이어그램<br>
```
- 객체하나를 대상으로 생성-소멸 기간 중 다양하게 가질수 있는 상태를 분석하기 위해 작성
- 객체의 동적 상태 변화를 정의 & 분석들 목적으로 사용
- 객체 상태 변화를 유발하는 이벤트를 정의 & 분석하기 위해 사용
```
---
> 활동 다이어그램<br>
```
- 시작점, 활동, 종료점, 전이로 구성
- 표현 : 분기, 동기화 막대, 신호, 구획면
- 주로 유스케이스 수준이상의 비즈니스 프로세스를 표현
- 분석단계에서 유스케이스 내부에 대한 구체적인 흐름을 나타내기 위해 사용
- 순차 or 통신 다이어그램에서 나타내기 어려운 상황을 표현할 수 있음
- 업무 흐름을 분석하거나 화면 흐름을 표현할 때 유용
```
---
> 모델 검증 방법<br>
```
- 리뷰
- 테스팅
- 정형적 방법
- 프로토 타이핑
- 요구 추적
```
---
> 설계<br>
```
- 주로 품질과 관련
- 의사결정과정이면서 동시에 시스템을 알아가는 과정
```
---
> 설계의 기본개념<br>
```
- 분할 정복, 추상화, 합성등의 원리를 적용
- 높은 수준의 의사결정과정의 연속
- 아키텍처기반의 설계 방법
- 서브 시스템, 모듈의 개념과 설계 작업의 관점, 설계 작업과정을 숙지해야함
```
---
> 소프트웨어 개발과정의 다양한 형식<br>
```
- 요구모델링 단계에는 유스케이스나 기능리스트로 설계단계에는 서브시스템 구조로, 구현단계에는 원시코드, 제어흐름도 등으로 표현됨
- 원시코드나 실행되는 소프트웨어 형식에는 설계의도가 잘 드러남
- 전통적인 설계 : Topdown, Bottom up, 분할 정복등 기능 실현에 초점
- 아키텍처 설계 : 관점에 근거한 품질중심 설계 작업
```
---
> 아키텍터의 3가지 관점<br>
```
- 모듈 관점 : 일정한 책임을 구현한 코드 단위인 모듈과 그 관계로 소프트웨어 구조를 설명하는 관점
            : 분할, 사용관계, 계층 구조, 데이터 모델
- 컴포넌트 관점 : 실행될 때 동작하는 요소와 상호작용으로 구조를 설명하는 관점
               : 클라이언트 서버, 파이프 필터, 출판 구독, 이벤트 중심, 리파지토리
- 할당 관점 : 소프트웨어의 하드웨어 배치, 설치, 작업 할당, 구현, 데이터 저장의 대한 관점
           : 배치, 설치, 작업 할당, 구현 데이터 저장
```
---
> lass<br>
- 사용자는 클래스에서 제공하는 연산기능만 알고 불필요한 연산과 데이터는 감춤
---
> 캡슐화<br>
```
- 객체 내용의 서로 관련된 데이터와 그 데이터를 조작할 수 있는 메서드를 같이 포장
- 그안에 포함된 메서드만 사용하여 데이터 값을 변경가능
<장점>
  - 데이터 보호
  - 추상화 용이
  - 제공자와 이용자를 명확히 분리
  - 이용자에게 편리성 제공
  - 사용법이 쉬움
  - 변화에 대한 국지적 영향
  - 객체간의 독립성 보장
  - 변경 용이성과 재사용성 증대
```
---
> 모듈<br>
```
- 규모가 큰것을 여러개로 나눈 조합
- 소프트웨어 구조를 이루는 기본적인 단위
- 하나 또는 몇개의 논리적 기능을 수행하기 위한 명령어들의 집합
- 독립프로그램도 하나의 모듈, 함수(메서드)들도 하나의 모듈
<장점>
  - 분할과 정복 원리가 적용되어 복잡도 감소
  - 문제를 이해하기 쉽게 만듬
  - 변경하기 쉽고, 변경으로 인한 영향이 적음
  - 유지보수가 용이함
  - 프로그램을 효율적으로 관리 가능
  - 오류로 인한 파급효과를 최소화할 수 있음
  - 설계 및 코드를 재사용할 수 있음
```
---
> 결합도<br>
- 모듈과 모듈 사이의 관계에서 관련 정도
- 좋은 설계란 상호 의존성이 줄어 모듈의 독립성이 높아지고, 모듈간에 영향이 적으면 좋기에 결합도는 낮을수록 좋다
```
<순서>
데이터 결합 > 스탬프 결합 > 제어 결합 > 공통 결합 > 내용 결합
1. 데이터 결합 : 가장 좋음, 데이터만 주고 받음 , 간섭을 최소화
2. 스탬프 결합 : 필요한 데이터만 주고받을 수 없고 필요없는 데이터까지 전체를 주고받아야 함
3. 제어 결합 : 제어 플래그를 매개변수로 사용하여 간섭, 호출하는 모듈이 논리적 흐름을 변경할 수 있음
4. 공통 결합 : 공통 변수(전역 변수)를 같이 사용하여 발생하는 관계
5. 내용 결합 : 상대 모듈의 대이터를 직접 변경, 인터페이스를 사용하지 않고 직접 왔다 갔다 하는 관계
```
---
> 응집도<br>
- 모듈 내부에 존재한 구성 요소들 사이에 밀접한 정도
- 높을 수록 좋음
```
<순서>
기능적 음집 > 순차적 응집 > 교환적 응집 > 절차적 응집 > 시간적 응집 > 논리적 응집 > 우연적 응집
1. 기능적 응집 : 단일 기능의 요소를 하나의 모듈을 구성
2. 순차적 응집 : 하나의 요소의 출력을 다른 요소의 입력으로 사용 => 두 요소가 하나의 모듈을 구성한 경우
3. 교환적 응집 : 정보적 응집, 순서는 중요 x, 같은 입력을 사용하는 구성 요소들을 하나의 모듈로 구성
4. 절차적 응집 : 순서가 정해진 몇 개의 구성요소를 하나의 모듈로 구성, 오직 순서에 따라 수행 ( 출력이 입력으로 사용되지는 않음)
5. 시간적 응집 : 구성요소들이 같은 시간대에 함계 실행된다는 이유로 하나의 모듈로 구성
6. 논리적 응집 : 요소들 간에 공통점이 있거나 관련된 임무가 존재하거나 기능이 비슷하다는 이유로 하나의 모듈로 구성
7. 우연적 응집 : 이유 없이 우연히 같이 묶임 
```
---
> 인터페이스와 구현분리<br>

---
> 원칙<br>
```
- 단일 책임원칙 : 클래스는 한가지 책임(기능)만 갖도록 설계하자
- 개방 폐쇄의 원칙 : 확장(상속)에는 열려 있어야하고 벼경에는 닫혀 있어야 한다
- 리스코프 교체의 원칙 : 기반 클래스는 파생 클래스로 대체할 수 있어야 한다 -> 구 버전에서 작업한 내용을 신 버전에서도 문제없이 잘 작동함을 의미
- 인터페이스 분리의 원칙 : 하나의 일반적인 인터페이스보다는 구체적인 여러개의 인터페이스가 낫다
- 의존 관계 역전의 원칙 : 클라이언트는 구체 클래스가 아닌 추상 클래스(인터페이스)에 의존해야 한다
```
---
> 객체지향 메트릭<br>
```
- 클래스 당 가중 메소드(WMC) : 클래스 안에 있는 메소드의 복잡도 메트릭의 합 -> 복잡도
- 상속 트리의 깊이(DIT) : 상속 트리의 루트로부터 해당 클래스까지 가장 깊은 상속 경로 -> 상속 깊이
- 자식 노드의 개수(NOC) : 클래스의 상속 구조에서 직계 자식 클래스의 수 -> 상속 너비
- 클래스 사이의 결합(CBO) : 당 클래스가 의존하고 있는 클래스의 수 -> 결합도
- 클래스의 책임(RFC) : 클래스의 메소드 개수에 그 클래스의 메소드가 호출하는 메소드의 개수 -> 크기
- 메소드의 응집 결핍 : 소속된 클래스의 속성을 공유하지 않는 메소드 쌍의 수 -> 응집도
```
> 아키텍처의 정의<br>
---
```
- 구성요소
- 구성요소들 사이의 관계
- 구성요소들이 외부에 드러내는 속성
- 구성요소들과 주변 환경 사이의 관계
- 구성 요소들과 주변 환경 사이의 관계
- 구성 요소들이 제공하는 인터페이스
- 구성요소들의 협력 및 조립 방법
```
---
> 아키텍처의 구성요소<br>
- 서브시스템 수준의 덩어리화 작업
- 구성 요소의 역할과 구성 요소 간의 관계에 집중
---
> 아키텍처의 역할<br>
```
- 시스템의 구조를 확립하는 소프트웨어 개발의 중심축
- 설계, 구현과 통합, 테스팅까지 통합하는 벼대
- 모든 단계에 영향을 줄만한 초기 의사결저으이 핵심
```
---
> 아키텍처의 표현관점<br>
```
- 유스케이스관점 : 시스템이 사용자에게 제공하는 기능에 관심
- 논리적 관점 :클래스나 컴포넌트의 종류와 이들의 관계에 초점
- 구현 관점 : 소프트웨어 서브 시스템의 모듈이 어떻게 구조화되어 있는가에 관심
- 프로세스 관점 : 시스템의 내부 구조에 초점, 동시성과 동기화에 관심
- 배치 관점 :시스템을 구성하는 처리 장치 간의 물리적 배치에 초점
```
---
> 아키텍처 스타일 설계시 장점<br>
```
- 개발 기간 단축, 고품질의 소프트웨어 생산
- 수월한 의사소통
- 용이한 요지보수
- 검증된 아키텍처
- 구죽전 시스템 특성에 대한 시뮬레이션 가능
- 기존 시스템에 대한 빠른 이해                                   
```
---
> 아키텍처 스타일의 기능<br>
```
- 소프트웨어 시스템의 구조를 체계적으로 구성하기 위해 기본 스키마를 제시
- 미리 정의된 서브 시스템 제공
- 각 아키텍처 패턴 간의 책임 명시
- 패턴 간의 관계를 조직화하는 규칙, 가이드 라인 제시
- 문제를 소프트웨어 모듈 단위로 분해하는 방법 제시
- 분해한 소프트웨어 모듈 단위가 상호작용하는 방법 제시
```
---
> 아키텍터 스타일의 종류<br>
```
- 클라인언트 서버형 : 네트워크를 이용하는 분산 시스템 형태
- 계층형 : 기능을 몇개의 계틍으로 나누어 배치
- MVC : 중앙 데이터 구조, 모델의 서브시스템에 대하여 여러 뷰 서브 시스템을 필요로 하는 시스템에 적합
- 파이프 필터 : 필터 사이에 데이터를 이동시키면서 단계적 처리
- 데이터 중심의 아키텍처 : 주요 데이터가 REPOSITORY에서 중앙관리
- PEER TO PEER 스타일 : 각 컴포넌트는 동등하여 서비스를 요청하는 클라이언트에 동시에 서비스를 제공하는 서버역할
                      : 동이한 수신, 전송 데이터양을 가지므로 대칭적인 시스템
```
---
> 디자인 패턴<br>
- 디자인 패턴은 아키텍처 설게 수준의 설계 문제에 재사용 가능한 솔루션을 제공함
---
> 디자인 패턴의 장단점<br>
```
< 장점 >
  - 개발자(설계자) 간의 원할한 의사소통
  - 소프트웨어 구조 파악 용이
  - 재사용을 통한 개발 시간 단축
  - 설계 변경 요청에 대한 유연한 대처
< 단점 >
  - 객체지향 설계/구현 위주
  - 초기 투자 비용 부담
```
---
> 디자인 패턴의 형식<br>
```
- 짧은 설명과 이름은 의사소통을 촉진하고 디자인 아이디어를 논의하기 위한 어휘를 제공
- 각 디자인 패턴에 대한 설명은 배경을 정의하고 패턴을 학습하는 동기를 제공하는 소개로 시작함
- 해당 디자인 패턴이 적용되는 문제가 무엇인지 알아야 하며, 디자인 패턴으로 해결되는 설계 이슈에 대해 설명함
```
---
> 싱글톤 패턴<br>
```
- 정확히 하나의 요소만 갖는 집합
- 특정 클래스의 객체가 오직 한개만 존재하도록 보장
- 즉, 클래스의 객체를 하나로 제한
```
---
> 반복자 패턴<br>
```
- 데이터들의 집합체를 모두 동일한 인터페이스를 사용하며 조작함으로써 데이터들의 집합체를 쉽게 사용할 수 있게 해줌
- 반복이 필요한 자료구조를 모두 동잏한 인터페이스를 통해 접근할 수 있도록 iterator 객체의 메서드를 이용해 자료구조를 활용할 수 있도록 해줌
- 집합 클래스의 자료구조와 상관없이 집합에 소속된 요소들을 쉽게 접근하기 위해 반복자에게 위임
```
---
> 어뎁터 패턴 <br>
```
- 사용가능한 서비스의 인터페이스를 클라이언트가 예상하는 인터페이스에 맞게 조정
- 기존 클래스를 재사용할 수 있도록 맞춰주는 역할
- 호환성이 없는 기존 클래스의 인터페이스를 변환해 재사용할 수 있도록 해줌
```
---
> 데코레이션 패턴<br>
```
- 기존에 구현된어 있는 클래스에 따라 그때 그때 필요한 기능을 추가해나가는 설계 패턴
- 기능 확장이 필요시 상속의 대안으로 사용
- 합관계와 위임을 사용하여 기존 클래스의 동작을 가볍고 유연하게 확장
```
---
> 팩토리 메소드 패턴<br>
- 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식
---
> 추상 메서드 패턴<br>
- 여러개의 concrete Product를 추상화 시킨 것
---
> 상태 패턴<br>
- 동일한 동작을 객페 상태에 따라 다르게 처리해야 할 때 사용
---
> 옵서버 패턴<br>
- 데이터를 보관하고 있는 Subject가 그 데이터를 이용하는 옵서버와 효과적으로 통신하면서 느슨하게 결합
---
> SAAM<br>
- 아키텍처가 시나리오를 실행할 수 있는지 여부를 결정
---
> ATAM<br>
- 여러가지 품질 속성에 맞추어 평가하여 아키텍터의 Trade-off, 설계 타협점을 찾아냄
---








































