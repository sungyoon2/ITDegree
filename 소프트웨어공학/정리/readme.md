# 소프트웨어 공학 정리
> 소프트웨어<br>
```
- 하드웨어를 이용하여 데이터를 처리하고 정보를 제공하여 여러응용 분야 업무를 자동화한다
- 컴퓨터를 작동시키는 program
- 하드웨어의 동작을 제어하는 수많은 명령어로 구성
```
---
> 소프트웨어 공학<br>
- 소프트웨어의 규모가 커질수록 프로그래밍보다 개발과정과 계획, 사용된 도구들이 생산성, 품질에 큰 영향을 미치기에 만들어진 공학
- 주된 목적은 주어진 비용과 자원안에서 품질 좋은 s/w를 기간내 생산
---
> 패키지형 소프트웨어<br>
- s/w에 대한 요구는 전적으로 시장 요구에 의해 결정
---
> 검증<br>
- 프로그램의 실행후 예상결과를 check, 실행전 원시코드를 인스펙션하여 요구사항과 일치하는지 확인하는 작업
---
> 품질 보증<br>
- 개발작업이 적절히 수행되었는지 확인
---
> 요구 분석<br>
- 소프트웨어 시스템이 해결 할 문제를 이해하기 위한 작업
---
> SWEBOK(Software Engneering Body of Knowledge)<br>
- 소프트웨어 개발분야의 엔지니어가 알아야할 지식체계를 공공성 있는 기관에서 누구나 동의할만큼 잘 정의
---
> 컴퓨터 과학<br>
- 계산적 효율, 자원 공유, 정확성, 성능 강조
- 개선을 위한 방법, 알고리즘, 원리, 기술을 다룸 => 정량적, 즉시 측정 가능
---
> 소프트웨어 공학<br>
- 생산성, 품질, 비용 시간을 목표로 개선하기 위함
---
> 소프트웨어 프로세스 모델<BR>
- 프로젝트의 작업공정을 구성하는 일반적인 접근방법
- 즉, 어떤 작업, 어떤 순서로 작업해야하는 지 결정하는데 도움
---
> 방법론<br>
- 이떤일을 하기 위한 방법으로 단계나 작업으로 구성됨
---
> 프로세스<br>
```
- 단계적 작업의 틀을 정의
- 무엇을 하는가에 중점
- 결과물이 표현에 대하여 언급x
- 패러다임에 대해 독립적
```
---
> 테스트<br>
```
- 개발자 또는 사용자 시각에 떄른 분류
- 사용되는 목적에 따른 분류
- 품질 특성에 따른 분류
```
---
> 소프트웨어 프로젝드<br>
```
- 설계가 끝나면 프로그램밍 작업에 들어감
- 설계 작업까지는 프로그램에 대한 언급x, 주로 기능과 외형(ui), 데아터베이스에 대해 설계
- 소프트웨어의 기능과 컴포넌트의 독립관계를 정확히 작성 후 프로그램 시작
- 소프트웨어 시스템을 구성하는 컴포넌트와 인터페이스에 대해 정의
```
---
> 소프트웨어 프로세스<br>
```
<개념>
- 프로젝트는 단계로 이루어짐
- 각 단계는 프로젝트 목표를 만족시킬수 있는 잘 정의된 작업으로 정의 되어야함
- 비용을 줄이기 위해 그 단계에 유입된 결함을 찾아내는데 초점
<특징>
- 입력과 결과물 즉, 진입조건과 출구조건, 결함을 찾기위한 검증작업 필요, 프로세스 관리를 위한 정보를 생성할 필요가 있음
```
---
> 결함제거 용이성<br>
```
- 개발과정의 모든 단계에서 오류가 발생가능함
- 오류를 발견하고 수정하는 소요되는  노력은 발생시점에 따라 다름
- 오류발생루 발견이 지연될수록 수정하는데 드는 비용이 늘어남
- 요구에 오류가 있다면 설계와 코드에 영향을 줌
```
---
> 프로토 타입 모델<br>
- 대량생산에 앞서서 미리 제작해보는 원형 또는 시제품
- 사용자와의 의사소통의 도구로 활용
---
> 나선형 모델<br>
- 소프트웨어 기능을 나누어 점증적 개발
- 여러번의 점증적인 릴리즈를 거침
---
> ISO/IEC12207<br>
```
- 소프트웨어 생명주기 프로세스 국제표준
- 시스템을 공급하려면 소프트웨어 개발 프로세스 뿐만아니라 문서와 형상관리,품질보증, 검사등의 지원 프로세스관리, 개선, 교육등의 조직 프로세스도 필요
```
---
> 프로젝트 관리 프로세스<br>
- 비용& 품질목표를 달성하기 위하여 관리하는 모든 작업
- 선택된 개발프로세스가 잘 구현 됬는지 확인하는 것
---
> 인스펙션 프로세스의 특성<br>
```
- 참석자의 역할이 정해진 process
- 전문기술인력이 담당
- 해결방법이 아닌 문제 자체에 집중
- 검토자료는 기록하며, 인스펙션 작업의 효율성을 모니터링하는데 사용
```
---
> 제어 분석<br>
- 모니터링에 의해 확인된 사실을 분석하고 계획과 치이나는 부분에 대하여 조정하고 조치하는 것
---
> 모니터링<br>
- 개발하는 동안 수행하는 모든 작업이 프로젝트의 목적과 부합되며, 개발이 계획대로 진척되는지 확인하기 위해 데이터를 수집하는 것
---
> 프로젝트<br>
- 정해진 기간안에 한정된 자원으로 일정한 목적을 달성하기 위해 수행하는 업무
---
> 프로젝트의 가치평가<br>
```
- 투자 회수 시간 : 투자금과 같은 금액을 벌어들이는 데 걸리는 시간
- ROI(Return of Investment) : 총비용에 대한 연간 평균 이익률
- 순수 현재 가치 : 현재 투자금과 미래 수익금을 현재 가치로 비교하는 방법
- 평가표 : 금액적인 요소 이외에 기술, 품질, 시간 여유, 인력 동을 고려하여 점수화하는 방법
- SWOT : 강점, 약점, 기회요인, 위협요인을 파악하여 타당성을 이해
```
---
> 타당성 분석 내용<br>
```
- SOW : 프로젝트가 성취해야 할 일
- 비즈니스 목표(가치) : 프로젝트의 결과물
- 예산 : 비용과 수익의 요약
- 프로젝트 일정 : 대략적인 일정
- 프로젝트 리스크 : 위험요소
- 대안 : 구축, 구매 등의 방법
- 평가
```
---
> 작업분할 구조도(WBS)<br>
```
- 사용자와 개발자간의 의사소통도구로 사용
- 프로젝트업무 내역을 가시화 할 수 있어 관리가 용이
- 프로젝트 팀원의 책임과 역할을 분명히 할 수 있음
- 필요 인력과 일정 계획을 세우는데 기초로 활용
- 개발비 산정시 기초로 활용
- 성과 측정 및 조정 시 기준선으로 활용
```
---
> 비용예측의 중요한 변수<br>
- 투입되는 엔지니어 인원수, 작업가간  => D = E/M(노력, 자원, 기간) 관계
---
> COCOMO초기 모델<br>
```
- 원시 프로그램규모에 의한 방법
- 먼저 완성될 시스템의 규모를 추정 -> 이를 준비된 식에 대압 -> 소요 M/M을 예측
```
---
> 기능점수<br>
```
- 정확한 라인수 예측 불가
- 입력, 출력, 질의, 파일, 인터페이스의 개수로 소프트웨어 규모 나타냄
- 각 기능에 가중값
- 가능점수 1을 구현하기 위한 LOC
```
---
> 기능 점수 산정의 특징<br>
```
(특징)
- 소프트웨어 규모를 측정하는 방법
- 기능적 요구 사항이 중심이 되는 측정법
- 소프트웨어의 요구사항 복잡도를 측정
- 구현 관점x(즉, 구현되는 언어에 상관없음), 사용자 관점의 요구기능을 정량적으로 산정
- 개발 규모를 예측하는데 적합
(단점)
- 모든 항목에 일률적인 가중치가 적용되므로 문제가 생길 수 있음
- 요구사항으로부터 기능을 도출하려면 상당한 분석능력 필요
- 이 방법으로 잘 사용할 수 있는 전문가가 필요
- 사용자가 알수 있는 기능으로 측정하기에  내부로직위주의 sw측정에는 부적합
```
---
> 모니터링의 목적<br>
```
- 프로젝트의 현황파악
- 차이를 분석하여 필요시 조치를 취하기 위함
```
---
> 일정을 모니터링하는 기본개념<br>
- 계획된 일정(주어진 시간계획의 스냅샷)을 기초로 실행값 비교
---
> 리스크 관리<br>
```
- 계획단계에는 목적달성을 위한 다양한 불확정성을 다루어야함
- 계획은 미리 명시되 있으나, 성취하기위한 현실은 변화와 부정적 요인이 많음
- 리스크 관리 => 위험요인 파악, 평가관리하는 기술과 노하우 프로세스를 의미
```
---
> 어닝벨류 분석<br>
```
- 기본적인 원리는 맨파워를 비용으로 봄
- 진척도를 노력으로 비교 가능
- 예산과 비용이 녹아있어 사용이 편리
- 과정은 복잡 but 전체적인 진척상황을 이해하기 쉬움
- 계획된 노력(비용), 실제 진척도(어닝벨류), 노력(실제비용)을 금전적 가치로 측정하여 통합된 모니터링 제공
```
---
> 번다운 차트<br>
```
- 애자일 프로세스 중 스크럽에서 수행된 작업보다 남아있는 작업에 초점을 두어 일정을 모니터링
- 스크럼에서 구현될 각 기능에 정상적인 투입시간을 할당
- 각 기능은 스프린트에 배정되어 기능의 완성되면 소멸되는 스프린트 점수로 기록
- 번다운 차트의 목표는 출시되는 속도를 측정하는 것
```
---
> 요구<br>
- 시스템이 무엇을 해야하고 어떤 특징을 가져야 하는지 명확히 정의
---
> 요구분석<br>
```
- 제품의 버전을 개발 & 프로젝트의 범위를 결정
- 추측결과는 분석으로, 분석 후 부족한 점 or 문제점은 다시 추출과정으로 피드백
- 무엇을(what)에 초점
- 응용영역의 지식으로부터 출발하여 문제를 찾아내고 새로운 시스템이 이를 해결하기 위한 동작 서비스를 찾아내어 정리하는 작업
```
---
> 요구분석 명세서<br>
```
- 다양한 이해관계자로부터 요구사항을 수집후 시스템 분석가가 작성한 문서
- 의도하는 소프트웨어가 사용자, 하드웨어, 외부시스템과 어떻게 상호작용하는지 정의 & 품질과 제한사항을 포함
- 고객으로부터 박은 요구사항은 먼저 자연어로 작성
- 시스템분석가는 요구사항을 모델릴언어로 문서화해 개발팀이 쉽게 이해하여 구현에 사용할 수 있게함
- 분석한 요구사항(제약조건, 성능에 관한 사항)을 빠짐없이 명확히 명기
- 요구분석과정의 최종 산물 -> 설계의 구현에서 참조할 사항, 전반적으로 알아야할 사항을 포함
```
- (개발자의 관점)
```
- 읽고 어떤 시스템이 개발될지 이해하는데 사용
- 기술된 기능적/비기능적 요구사항을 기반으로 분석, 설계, 코딩
- 개발완료후 구현의 점검항목으로 사용
- 사용자 지침용 초안 작성용으로 사용
```
---
> 기능요구<br>
```
- 시스템이 데이터나 인스트럭션에 대해 반응하는 동작이나 상태변화
- 입력자료가 제공되어 이를 변환처리하여 결과를 출력
- 시스템이 무엇을 하는지, 어떤 기능을 갖는지 기술하면 됨
- 성능이나 효율, 반응 시간, 제약 조건등은 기능 외적인 요구에 해당
```
---
> 비기능요구<br>
```
- 시스템 제공하는 기능에 직접 관련되지 않은 요구 -> 파생적으로 필요한 요구
- 시스템 구축에 필요한 성능, 보안, 품질, 안전등에 대한 요구사항
```
---
> 시나리오<br>
```
- 개발자와 사용자의 가장 큰 장벽인 서로 다른 전문영역의 용어에 대한 이해와 해석(용어와 개념을 전달하여 요구를 도출)
- 5W1H로 표현하면 효과적, when,who, what이 중요
```
---
> 도메인 분석<br>
```
- 요구의 배경을 알아보는 것을 의미
- 소프트웨어 구축시 문제가 무엇인지, 이해 & 문제를 해결하기위해 무엇이 요구되는지 알아야하며, 문제가 어디에 놓여있냐도 중요하기에 실행
- 소프트웨어 적용분야에 대해 깊은 이해는 없을시 -> 소프트웨어를 설계하는 것이 불가능
- 설계모델링에 필요한 여러개념과 비지니스 규칙을 파악하기 위함
```
---
> 요구분석에서 사용되는 시나리오의 흐름<br>
---
> 유스케이스 사이의 관계<br>
```
- 연관 : 해당 액터와 정보를 주고 받는 유스케이스와 설정
- 포함 : 하나의 유스케이스를 실행시, 같은 기능이 있는 다른 유스케이스가 반드시 수행되는 관계
- 확장 : 확장하는  유스케이스는 상위유스케이스로부터 어떠한 특정조건에 의해 실행
- 일반화: 액터들이 유스케이스와 중복하여 관계가 나타나면 액터들을 통합하여 중복된 부분이 있을 때 설정
- 중복 : 유스케이스 모델링시 유스케이스 이벤트 흐름에서 중복된 부분이 있을 때 설정
```
---
> 요구명세(SRS)<br>
```
- 프로젝트 산출물 중 가장 중요한 문서
- 개발 프로젝트에 대한 공통 목표 제시
- 대상 시스템이 무엇을 수행할 것 인가에 대해 기술
- 시스템이 이루어야할 목표를 기술, 달성하기 위한 해결방법을 기술하는 것은 아니다
```
---
> 요구검증<br>
```
- 사용자의 요구가 요구분석명세서에 올바르게 기술되었는지 검토
- 초기단계에서 매우 중요한 의미
- 발견 못할 시 구현 후 결함이 되며 추후 수정에 비용이 많이 듬
- 요구분석단계에서 발생하는 오류가 비율이 많음 => 오류 유입을 맏는 법 : 리뷰, 워크스루....
```
---
> UML<br>
```
- Unified Modeling Language
- 시스템 개발을 위한 시각적인 설계표기를 제공하는 것
- 시각화 언어 : 소프트웽어의 개념모델을 시각적인 형태로 표현하여 표준화된 다이어그램을 제공
```
---
> 요구모델링의 이유<br>
```
- 복잡함을 잘 관리하기위해
- 형체 X, 소프트웨어의 구조를 시각화하기 위해
- 다른 사람과 커뮤니케이션 하기 위해
- 문제 도메인 및 제품요구사항을 이해하기 위해
```
---
> UML모델링 과정<br>
```
1. 요구를 사용 사례로 정리하고 사용 사례 다이어그램을 작성
2. 클래스 후보를 찾아내고 개념적인 객체 모형을 작성
3. 사용 사례를 기초하여 순서 다이어그램을 작성
4. 클래스의 속성, 오퍼레이션 및 클래스 사이의 관계를 찾아 객체 모형을 완성
5. 상태 다이어그램이나 액티비티 다이어그램 등 다이어그램을 추가하여 UML 모델을 완성
6. 서브 시스템을 파악하고 전체 시스템 구조를 설계
7. 적당한 객체를 찾아내거나 커스텀화 또는 객체를 새로 설계
```
---
> UML이 제공하는 다이어그램<br>
```
- 유스케이스
- 클래스
- 순차
- 통신
- 활동
- 상태
- 컴포넌트
- 배치
- 패키지
```
---
> 객체지향<br>
- 자료구조를 중심으로 객체를 설계한 다음 이들의 흐름을 설계하는 방식
```
<기본요소>
- 객체
- 클래스
- 메세지 - 객체간의 상호 작용 수단
```
---
> 추상클래스<br>
```
- 클래스의 명칭과 메서드는 있으나 메서드 처리내용은 x
- 상속을 통해 메서드가 구현
- 추상 메서드외에 일반적인 속성과 메서드를 가질 수 있음
- 메서드의 다형성을 지원
```
---
> 링크<br>
```
- 통신다이어그램에서 객체사이를 연결
- 객체와 객체 간의 양방향 연관 관계
- 화살표 없는 실선으로 표현
- 이름 붙일 수 있음
```
---
> 동적모델링의 시퀸스 다이어그램<br>
```
- 순차 다이어그램
- 통신 다이어그램
- 상태 다이어그램
```
---
> 상태다이어그램<br>
```
- 객체하나를 대상으로 생성-소멸 기간 중 다양하게 가질수 있는 상태를 분석하기 위해 작성
- 객체의 동적 상태 변화를 정의 & 분석들 목적으로 사용
- 객체 상태 변화를 유발하는 이벤트를 정의 & 분석하기 위해 사용
```
---
> 활동 다이어그램<br>
```
- 시작점, 활동, 종료점, 전이로 구성
- 표현 : 분기, 동기화 막대, 신호, 구획면
- 주로 유스케이스 수준이상의 비즈니스 프로세스를 표현
- 분석단계에서 유스케이스 내부에 대한 구체적인 흐름을 나타내기 위해 사용
- 순차 or 통신 다이어그램에서 나타내기 어려운 상황을 표현할 수 있음
- 업무 흐름을 분석하거나 화면 흐름을 표현할 때 유용
```
---
> 모델 검증 방법<br>
```
- 리뷰
- 테스팅
- 정형적 방법
- 프로토 타이핑
- 요구 추적
```
---
> 설계<br>
```
- 주로 품질과 관련
- 의사결정과정이면서 동시에 시스템을 알아가는 과정
```
---
> 설계의 기본개념<br>
```
- 분할 정복, 추상화, 합성등의 원리를 적용
- 높은 수준의 의사결정과정의 연속
- 아키텍처기반의 설계 방법
- 서브 시스템, 모듈의 개념과 설계 작업의 관점, 설계 작업과정을 숙지해야함
```
---
> 소프트웨어 개발과정의 다양한 형식<br>
```
- 요구모델링 단계에는 유스케이스나 기능리스트로 설계단계에는 서브시스템 구조로, 구현단계에는 원시코드, 제어흐름도 등으로 표현됨
- 원시코드나 실행되는 소프트웨어 형식에는 설계의도가 잘 드러남
- 전통적인 설계 : Topdown, Bottom up, 분할 정복등 기능 실현에 초점
- 아키텍처 설계 : 관점에 근거한 품질중심 설계 작업
```
---
> 아키텍터의 3가지 관점<br>
```
- 모듈 관점 : 일정한 책임을 구현한 코드 단위인 모듈과 그 관계로 소프트웨어 구조를 설명하는 관점
            : 분할, 사용관계, 계층 구조, 데이터 모델
- 컴포넌트 관점 : 실행될 때 동작하는 요소와 상호작용으로 구조를 설명하는 관점
               : 클라이언트 서버, 파이프 필터, 출판 구독, 이벤트 중심, 리파지토리
- 할당 관점 : 소프트웨어의 하드웨어 배치, 설치, 작업 할당, 구현, 데이터 저장의 대한 관점
           : 배치, 설치, 작업 할당, 구현 데이터 저장
```
---
> lass<br>
- 사용자는 클래스에서 제공하는 연산기능만 알고 불필요한 연산과 데이터는 감춤
---
> 캡슐화<br>
```
- 객체 내용의 서로 관련된 데이터와 그 데이터를 조작할 수 있는 메서드를 같이 포장
- 그안에 포함된 메서드만 사용하여 데이터 값을 변경가능
<장점>
  - 데이터 보호
  - 추상화 용이
  - 제공자와 이용자를 명확히 분리
  - 이용자에게 편리성 제공
  - 사용법이 쉬움
  - 변화에 대한 국지적 영향
  - 객체간의 독립성 보장
  - 변경 용이성과 재사용성 증대
```
---
> 모듈<br>
```
- 규모가 큰것을 여러개로 나눈 조합
- 소프트웨어 구조를 이루는 기본적인 단위
- 하나 또는 몇개의 논리적 기능을 수행하기 위한 명령어들의 집합
- 독립프로그램도 하나의 모듈, 함수(메서드)들도 하나의 모듈
<장점>
  - 분할과 정복 원리가 적용되어 복잡도 감소
  - 문제를 이해하기 쉽게 만듬
  - 변경하기 쉽고, 변경으로 인한 영향이 적음
  - 유지보수가 용이함
  - 프로그램을 효율적으로 관리 가능
  - 오류로 인한 파급효과를 최소화할 수 있음
  - 설계 및 코드를 재사용할 수 있음
```
---
> 결합도<br>
- 모듈과 모듈 사이의 관계에서 관련 정도
- 좋은 설계란 상호 의존성이 줄어 모듈의 독립성이 높아지고, 모듈간에 영향이 적으면 좋기에 결합도는 낮을수록 좋다
```
<순서>
데이터 결합 > 스탬프 결합 > 제어 결합 > 공통 결합 > 내용 결합
1. 데이터 결합 : 가장 좋음, 데이터만 주고 받음 , 간섭을 최소화
2. 스탬프 결합 : 필요한 데이터만 주고받을 수 없고 필요없는 데이터까지 전체를 주고받아야 함
3. 제어 결합 : 제어 플래그를 매개변수로 사용하여 간섭, 호출하는 모듈이 논리적 흐름을 변경할 수 있음
4. 공통 결합 : 공통 변수(전역 변수)를 같이 사용하여 발생하는 관계
5. 내용 결합 : 상대 모듈의 대이터를 직접 변경, 인터페이스를 사용하지 않고 직접 왔다 갔다 하는 관계
```
---
> 응집도<br>
- 모듈 내부에 존재한 구성 요소들 사이에 밀접한 정도
- 높을 수록 좋음
```
<순서>
기능적 음집 > 순차적 응집 > 교환적 응집 > 절차적 응집 > 시간적 응집 > 논리적 응집 > 우연적 응집
1. 기능적 응집 : 단일 기능의 요소를 하나의 모듈을 구성
2. 순차적 응집 : 하나의 요소의 출력을 다른 요소의 입력으로 사용 => 두 요소가 하나의 모듈을 구성한 경우
3. 교환적 응집 : 정보적 응집, 순서는 중요 x, 같은 입력을 사용하는 구성 요소들을 하나의 모듈로 구성
4. 절차적 응집 : 순서가 정해진 몇 개의 구성요소를 하나의 모듈로 구성, 오직 순서에 따라 수행 ( 출력이 입력으로 사용되지는 않음)
5. 시간적 응집 : 구성요소들이 같은 시간대에 함계 실행된다는 이유로 하나의 모듈로 구성
6. 논리적 응집 : 요소들 간에 공통점이 있거나 관련된 임무가 존재하거나 기능이 비슷하다는 이유로 하나의 모듈로 구성
7. 우연적 응집 : 이유 없이 우연히 같이 묶임 
```
---
> 인터페이스와 구현분리<br>

---
> 원칙<br>
```
- 단일 책임원칙 : 클래스는 한가지 책임(기능)만 갖도록 설계하자
- 개방 폐쇄의 원칙 : 확장(상속)에는 열려 있어야하고 벼경에는 닫혀 있어야 한다
- 리스코프 교체의 원칙 : 기반 클래스는 파생 클래스로 대체할 수 있어야 한다 -> 구 버전에서 작업한 내용을 신 버전에서도 문제없이 잘 작동함을 의미
- 인터페이스 분리의 원칙 : 하나의 일반적인 인터페이스보다는 구체적인 여러개의 인터페이스가 낫다
- 의존 관계 역전의 원칙 : 클라이언트는 구체 클래스가 아닌 추상 클래스(인터페이스)에 의존해야 한다
```
---
> 객체지향 메트릭<br>
```
- 클래스 당 가중 메소드(WMC) : 클래스 안에 있는 메소드의 복잡도 메트릭의 합 -> 복잡도
- 상속 트리의 깊이(DIT) : 상속 트리의 루트로부터 해당 클래스까지 가장 깊은 상속 경로 -> 상속 깊이
- 자식 노드의 개수(NOC) : 클래스의 상속 구조에서 직계 자식 클래스의 수 -> 상속 너비
- 클래스 사이의 결합(CBO) : 당 클래스가 의존하고 있는 클래스의 수 -> 결합도
- 클래스의 책임(RFC) : 클래스의 메소드 개수에 그 클래스의 메소드가 호출하는 메소드의 개수 -> 크기
- 메소드의 응집 결핍 : 소속된 클래스의 속성을 공유하지 않는 메소드 쌍의 수 -> 응집도
```
> 아키텍처의 정의<br>
---
```
- 구성요소
- 구성요소들 사이의 관계
- 구성요소들이 외부에 드러내는 속성
- 구성요소들과 주변 환경 사이의 관계
- 구성 요소들과 주변 환경 사이의 관계
- 구성 요소들이 제공하는 인터페이스
- 구성요소들의 협력 및 조립 방법
```
---
> 아키텍처의 구성요소<br>
- 서브시스템 수준의 덩어리화 작업
- 구성 요소의 역할과 구성 요소 간의 관계에 집중
---
> 아키텍처의 역할<br>
```
- 시스템의 구조를 확립하는 소프트웨어 개발의 중심축
- 설계, 구현과 통합, 테스팅까지 통합하는 벼대
- 모든 단계에 영향을 줄만한 초기 의사결저으이 핵심
```
---
> 아키텍처의 표현관점<br>
```
- 유스케이스관점 : 시스템이 사용자에게 제공하는 기능에 관심
- 논리적 관점 :클래스나 컴포넌트의 종류와 이들의 관계에 초점
- 구현 관점 : 소프트웨어 서브 시스템의 모듈이 어떻게 구조화되어 있는가에 관심
- 프로세스 관점 : 시스템의 내부 구조에 초점, 동시성과 동기화에 관심
- 배치 관점 :시스템을 구성하는 처리 장치 간의 물리적 배치에 초점
```
---
> 아키텍처 스타일 설계시 장점<br>
```
- 개발 기간 단축, 고품질의 소프트웨어 생산
- 수월한 의사소통
- 용이한 요지보수
- 검증된 아키텍처
- 구죽전 시스템 특성에 대한 시뮬레이션 가능
- 기존 시스템에 대한 빠른 이해                                   
```
---
> 아키텍처 스타일의 기능<br>
```
- 소프트웨어 시스템의 구조를 체계적으로 구성하기 위해 기본 스키마를 제시
- 미리 정의된 서브 시스템 제공
- 각 아키텍처 패턴 간의 책임 명시
- 패턴 간의 관계를 조직화하는 규칙, 가이드 라인 제시
- 문제를 소프트웨어 모듈 단위로 분해하는 방법 제시
- 분해한 소프트웨어 모듈 단위가 상호작용하는 방법 제시
```
---
> 아키텍터 스타일의 종류<br>
```
- 클라인언트 서버형 : 네트워크를 이용하는 분산 시스템 형태
- 계층형 : 기능을 몇개의 계틍으로 나누어 배치
- MVC : 중앙 데이터 구조, 모델의 서브시스템에 대하여 여러 뷰 서브 시스템을 필요로 하는 시스템에 적합
- 파이프 필터 : 필터 사이에 데이터를 이동시키면서 단계적 처리
- 데이터 중심의 아키텍처 : 주요 데이터가 REPOSITORY에서 중앙관리
- PEER TO PEER 스타일 : 각 컴포넌트는 동등하여 서비스를 요청하는 클라이언트에 동시에 서비스를 제공하는 서버역할
                      : 동이한 수신, 전송 데이터양을 가지므로 대칭적인 시스템
```
---
> 디자인 패턴<br>
- 디자인 패턴은 아키텍처 설게 수준의 설계 문제에 재사용 가능한 솔루션을 제공함
---
> 디자인 패턴의 장단점<br>
```
< 장점 >
  - 개발자(설계자) 간의 원할한 의사소통
  - 소프트웨어 구조 파악 용이
  - 재사용을 통한 개발 시간 단축
  - 설계 변경 요청에 대한 유연한 대처
< 단점 >
  - 객체지향 설계/구현 위주
  - 초기 투자 비용 부담
```
---
> 디자인 패턴의 형식<br>
```
- 짧은 설명과 이름은 의사소통을 촉진하고 디자인 아이디어를 논의하기 위한 어휘를 제공
- 각 디자인 패턴에 대한 설명은 배경을 정의하고 패턴을 학습하는 동기를 제공하는 소개로 시작함
- 해당 디자인 패턴이 적용되는 문제가 무엇인지 알아야 하며, 디자인 패턴으로 해결되는 설계 이슈에 대해 설명함
```
---
> 싱글톤 패턴<br>
```
- 정확히 하나의 요소만 갖는 집합
- 특정 클래스의 객체가 오직 한개만 존재하도록 보장
- 즉, 클래스의 객체를 하나로 제한
```
---
> 반복자 패턴<br>
```
- 데이터들의 집합체를 모두 동일한 인터페이스를 사용하며 조작함으로써 데이터들의 집합체를 쉽게 사용할 수 있게 해줌
- 반복이 필요한 자료구조를 모두 동잏한 인터페이스를 통해 접근할 수 있도록 iterator 객체의 메서드를 이용해 자료구조를 활용할 수 있도록 해줌
- 집합 클래스의 자료구조와 상관없이 집합에 소속된 요소들을 쉽게 접근하기 위해 반복자에게 위임
```
---
> 어뎁터 패턴 <br>
```
- 사용가능한 서비스의 인터페이스를 클라이언트가 예상하는 인터페이스에 맞게 조정
- 기존 클래스를 재사용할 수 있도록 맞춰주는 역할
- 호환성이 없는 기존 클래스의 인터페이스를 변환해 재사용할 수 있도록 해줌
```
---
> 데코레이션 패턴<br>
```
- 기존에 구현된어 있는 클래스에 따라 그때 그때 필요한 기능을 추가해나가는 설계 패턴
- 기능 확장이 필요시 상속의 대안으로 사용
- 합관계와 위임을 사용하여 기존 클래스의 동작을 가볍고 유연하게 확장
```
---
> 팩토리 메소드 패턴<br>
- 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식
---
> 추상 메서드 패턴<br>
- 여러개의 concrete Product를 추상화 시킨 것
---
> 상태 패턴<br>
- 동일한 동작을 객페 상태에 따라 다르게 처리해야 할 때 사용
---
> 옵서버 패턴<br>
- 데이터를 보관하고 있는 Subject가 그 데이터를 이용하는 옵서버와 효과적으로 통신하면서 느슨하게 결합
---
> SAAM<br>
- 아키텍처가 시나리오를 실행할 수 있는지 여부를 결정
---
> ATAM<br>
- 여러가지 품질 속성에 맞추어 평가하여 아키텍터의 Trade-off, 설계 타협점을 찾아냄
---
> 사용자 시나리오의 작성순서<br>
```
1. 사용자 특성 파악
2. 시놉시스 작성
3. 시나리오 작성
```
---
> 멘탈 모델<br>
```
- 현실 세계의 사물이나 과정을 어떻게 작동하는 지에 대한 개인의 이해
- 시스템과의 상호작용, 다른 컴퓨터 프로그램에 대한 사용 경험 및 응용분야에 대한 지식으로 구성
```
---
> 스토리 보드<br>
```
- 사용자의 경험을 예상하고 탐색할 수 있도록 도와주는 도구로, 사용자 스토리 또는 사용자 시나리오를 기반으로 만든다.
- 작업자와 클라이언트가 이해할 수 있도록 만든 스케치
- 페르소나가 반드시 있어야됨
- 페르소나를 둘러싼 장소나 맥락, 상황과 역할이 명확하게 나타나고 그레 대해 구체적으로 설명되어 있어야만 한다.
```
---
> 시놉시스<br>
```
- 사용자를 통해 앱을 요약해 소개하는 내용
- 사용자가 앱에서 무엇을 얻고자 하는지에 대한 이야기로 구성하는 것
- 사용자의 이름, 직업, 성격, 사진 뿐만 아니라 오프라인 화ㄹ동이나 앱 이용 패턴등을 포함
```
---
> 페르소나<br>
```
- 가상의 사용자 또는 이를 통한 사용자의 역할 정의를 뜻함
- 사용자에게 공통으로 나타나는 이용패턴이나 이용심리등을 캐릭터로 특징 짓는 것을 의미
```
---
> 사용성 테스트의 시기<br>
- 테스트의 목적과 방향에 따라 달라짐
---
> 설문준비 및 테스트<br>
```
- 테스트 대상을 준비
- 사전, 사후 테스트 설문지 및 작업시나리오 정의
- 참가자에게 수행요청
- 사용성 테스트를 수행하고 데이터를 기록
```
---
> CLI<br>
- 사용자가 인터페이스에 단일 명령을 입력하면 컴퓨터가 수신하고 같은 방식으로 프롬프트에 응답하는 구조
```
- 고정적
- 비연속적
- 유도적
- 기억
```
---
> GUI<br>
- 아이콘이나 그림과 같은 그래픽 요소를 배치하고, 마우스 등의 포인팅 장치를 이용해 조작함
```
- 즉각적
- 우회적
- 탐험적
- 인지
```
---
> NUI<br>
- 사람과 컴퓨터의 상호작용을 위한 시스템
- 사용자의 일상적 행동과 관련된 직관적인 동작을 통해 작용하는 것을 의미
```
- 연산적
- 직접적
- 맥락적
- 직관
```
---
> OUI<br>
- 모든 사물을 입출력 장치로 변환할 수 있고, 인터페이스의 모양이나 상태도 자유롭게 변형 할 수 있음
```
- 유동적
- 광범위
- 예상가능
- 통합

```
---
> 화면 설계<br>
```
- 쉽게 배울수 있고, 사용할 수 있는 자료입력화면 가이드라인
- 항목의 입력이 끝났음을 알리기 위한 키를 반드시 정한다.
```
---
> 원할한 통합<br>
- 디자인 원칙에서 사용자는 갖자의 고유한 습관과 일정이 있는 것
---
> 단순함<br>
- 디자인 원틱에서 앱은 당연히 사용하기 편해야 하는 것
- 패턴을 배우기 위해 새롭게 노력할 필요가 없어야함
---
> 정중함<br>
- 디자인 원칙에서 사용자에세 유익하고 접근성이 좋게 디자인 해야한다는 것
- 잦은 알림과 같이 불필요한 장애물도 없어야함
---
> 타입리앱 디자인 프로세스<br>
```
1. 문제, 콘셉트
2. 대중, 니즈, 기본 영역, 요구 분석
3. 공감, 스케치
4. 와이어 프레임, 디자인 피드백
5. 비주얼 디자인, 스토리텔링
6. 프로토 타이핑
```
---
> 코딩작업<br>
- 셀계 명세에 나타난대로 요구를 만족할 수 있도록한 프로그래밀
---
> 메모리 누수<br>
- 메모리가 프리되지 않고 프로그램에 계속 할당되는 현상
---
> 자주발생하는 오류<br>
```
- 메모리 누수
- 중복된 프리선언
- NULL의 선언
- 별칭의 남용
- 배열 인덱스 오류 : 한도 벗어남 or 음수 값
- 수식 예외 오류
- 하나 차이에 의한 오류
- 사용자 정의 자료형 오류
- 스트링 처리 오류
- 버퍼 오류
- 동기화 오류
```
---
> 명명규칙<br>
```
<장점>
- 높은 가독성
- 간결하고 명확한 코딩
- 개발 시간의 단축
```
---
> 소스 형식에 관한 규칙<br>
```
- 소스 파일 하나는 200줄 이내로 작성
- 한 줄의 길이는 800자 이내로 작성
- 함수의 내용은 70줄 이내로 작성
- 여는 중괄호 {는 문장 끝, 닫는 중괄호}는 문장의 시작의 위치에
- 80자가 넘어 쉼표가 오면 다음 문자는 새줄로 시작
- 수준이 동일한 문장은 시작 위치를 동일하게
```
---
> 오류 처리<br>
```
- 잘못된 데이터를 어떻게 다룰 것인가
- 매개변수 오류
- 입력 오류 방지
```
---
> 리펙토링 개념<br>
```
- 결과의 변경없이 코드의 구조를 재조정
- 이미 존재하는 코드의 디자인을 안전하게 향상시키는 기술
- 가독성을 높이고 유지보수를 편하게 하기 위한 것
```
---
> 코드 스멜<br>
```
<종류>
- 프로그램에 대한 작업을 어렵게 만드는 것
- 읽기 어려운 프로그램
- 중복된 로직을 가진 프로그램
- 실행 중인 코드를 변경해야하는 특별한 동작을 요구하는 프로그램
- 복잡한 조건문이 포함된 프로그램
```
---
> 인스펙션<br>
- 설계든 코드든 결함을 찾아내고 이를 확인하려는 작업
---
> 정적 오류 분석<br>
```
- 프로그램 텍스트를 조직적을 분석하여 결함을 찾아내는 것
- 정적 분석하는 동안 프로그램은 실행되지 않음
```
---
> 테스트 중심 개발과정<br>
```
1) TDD를 준비
2) 테스트 코드 작성
3) 반복하여 기능을 구현하고 테스트
4) 테스트 커버리지 측정
```
---
> 짝 프로그래밍<br>
- 두 사람이 같은 컴퓨터를 사용하면서 다른 역할(개발과 테스팅)을 함
```
<장점>
- 상대가 있기에 프로그래밍에 재미가 있고 스트레스를 줄일 수 있음
- 팀의 소통을 향상
- 상호이해와 협력이 향상될 수 있음
- 토론이 창의적인 사고로 발전하여 문제 해결에 도움이 되므로 간단하고 효율적인 해법을 만들어 낼 수 있음
<단점>
- 모든 사람에게 맞지 않음
- 적절히 다르지 못하면 대화에 시간이 너무 많이 걸림 -> 대화는 문제의 해결과 작업 완성에 초점
- 서로간의 차이점에 적응하기 위해 시간이 걸릴 수 있음
- 스케쥴이 맞지않아 미팅 시간을 찾기 어려울 수 있음
- 결함을 발견을 위해 인스펙션과 같은 체계적인 리뷰만큼 효과적이지 않을 수 있다는 제약이 있음
```
---
> 소프트웨어 개념과 특징<br>
- 소프트웨어 내에 존재하지만 드러나지 않고 숨어 있는 오류를 발견할 목적으로, 개발 과정에서 생성되는 문서나 프로그램에 있는 오류를 여러 기술을 이용해 검출하는 작업
---
> 버그, 오류, 결함, 고장<br>
```
- 버그 : 문제, 결함, 또는 난이도를 나타내는 데 일반적으로 사용되는 용어
- 오류(error) : 소츠트웨어 개발자에 의해 만들어지는 실수로 결합의 원인이 됨
- 결함 : 오류에 의해 프로그램이 완전치 못한 것으로, 고자으이 원인이 됨
- 고장, 실패, 문제, 장애 : 시스템이 요구사항대로 작동하지 않는 것을 말함
```
---
> 소프트웨어 테스트 원리<br>
- 테스트는 오류를 발견하려고 프로그램을 실행시키는 것
---
> 소프트웨어 테스트 작업과정<br>
- 테스트 항목 중에서 어떤 항목을 중점적으로 테스트할 것인지 명확히 나타냄
---
> 블랙박스 테스트의 동등 분할 기법<br>
```
- 입력 값에 대한 예상출력 값을 정해놀고 그대로 결과가 나오는지를 체크
- 프로그램 내부의 구조나 알고리즘을 보지 않고, 요구분석 명세서나 설계 사양서에서 테스트 케이스를 추출하여 테스트
- 기능을 어떻게 수행하는가보다 사용자가 원하는 기능을 수행하는가 테스트
```
---
> 블랙박스 테스트의 경계 값 분석<br>
- 경계에 있는 값을 테스트 데이터로 생성하여 테스트 하는 방법
---
> 블랙박스 테스트의 원인 결과 그래프<br>
- 프로그램 명세가 의마하는 내용을 분석하여, 이에 알맞은 원인과 결과를 연결하는 논리 그래프를 작성함
---
> 화이트 박스 테스트의 논리 흐름의 표현<br>
```
- 문장 검증 기준(statement coverage)
- 분기 검증 기준(branch coverage)
- 조건 검증 기준(condition coverage)
- 분기/조건 검증 기준(branch/condition coverage)
- 다준 조건 점증 기준(multiple condition coverage)
- 기본 경로 테스트(basic path test)
```
---
> 화이트박스 테스트의 검증 기준<br>
- 프로그램 내의 모든 문장이 최소한 한번은 실행될 수 있는 테스트 데이터를 갖는 테스트 케이스를 선정
---
> 상태기반 테스트의 검증 기준<br>
```
- 같은 입력에 대해 같은 동작을 보이며 동일한 결과를 생성하는 시스템을 대상
- 배치 처리 시스템
- 계산 중심 시스템
- 하드웨어로 구성된 회로
```
---
> 통합 테스트에서 통합<br>
```
- 빅뱅 통합 : 모듈의 인터페이스 결합을 테스트
- 하향식 통합 : 시스템 구조상 최상위에 있는 모듈부터 통합
- 상향식 통합 : 시스템 구조상 최하위에 있는 모듈부터 통합
- 연쇄식 통합 : 특정 기능을 수행하는 모듈의 최소 단위(thread)로부터 시작
```
---
> 인수 테스트에서 테스트<br>
```
1) 기능 테스트
   - 컴포넌트 통합 후 수행하는 테스트 기법
2) 성능 테스트
   - 작업부하 : 시스템이 처리하고 생성하는 작업의 양
   - 처리량 : 트랜잭션의 수
   - 반응시간 : 시스템 요구를 처리하는데 걸리는 총 시간
   - 효율성 : 주어진 작업 처리를 위한 CPU시간과 메모리 같은 자원의 양의 비율
3) 보안 테스트
   - 시스템과 사용자에게 해를 입히려는 해커에게 이용될 수 있는 의도하지 않는 기능과 동작 시스템을 찾아내는 것
4) UI 테스트
   - 보고 느끼는 UI에 대한 결함
   - 데이터 입력과 출력 디스플레이에 대한 결함
   - 액터-시스템 사이의 동작 결함
   - 오류 처리에 대한 결함
   - 문서와 도움말에 대한 결함
5) 인수 테스트
   - 시스템을 당장 사용할 수 있도록 모든 중비가 되어 있는지 확인
   - 개발자를 제외한 의뢰자 또는 대리인이 테스트 수행
   - 시스템 요구 분석서를 기반으로 한 테스트 수행
   - 실제 업무 정차를 따라 테스트 수행
```
---
> 유지보수 변경의 이유와 유형<br>
```
- 개발 후에 이루어지는 소프트웨어의 변경 작업
- 소프트웨어가 유용하게 활용되는 기간
- 소프트웨어는 환경과 비즈니스 요구에 따라 진화함
- 요지보수에 드는 노력
```
---
> lehman의 법칙<br>
```
- 지속적인 변경의 원칙
- 엔트로피, 복접도 증가의 법칙
- 자기 통제의 법칙
- 안정성 유지의 법칙
- 친근성 유지의 법칙
- 지속적 성장의 법칙
- 품질 저하의 법칙
- 피드백 시스템의 법칙
```
---
> 유지보수 작업<br>
- 소프트웨어 개발은 코딩 중심의 작업이나 유지보수 활동을 원활히 수행할 수 있다는 장점이 있음
---
> 프로그램의 이해<br>
```
- 원시코드로부터 설계나 명세를 추출하여 멘탈 모델로 표현하는 작업
- 개발 프로세스와 반대로 추상성을 추구하는 방향
```
---
> 변경 파악과 분석<br>
```
- 변경 요구를 시초로 어떤 부분을 변경할지 찾아냄
- 다른 변경 방법(COTS)도 찾아냄
```
---
> 소프트웨어 형상관리<br>
- 소프트웨어의 개발 및 유지보수 과정에서 발생하는 각종 결과물들에 대한 계획, 개발 운용 등을 종합하여 시스템의 형상을 만들고, 이에 대한 변경을 체계적으로 과리, 제어하기 위한 활동
---
> 소프트웨어 형상관리 절차<br>
```
1) 소프트웨어 형상 파악
2) 형상 변경 제어
3) 소프트웨어 형상 감사
4) 소프트웨어 형상 상태 보관
```
---
> 역공학 작업순서<br>
- 대상 시스템을 분석하여 시스템의 컴포넌트와 관계를 찾아내어 같은 수준의 다른 표현이나 더 높은 수준의 표현으로 만드는 작업
---
> 재문서화<br>
```
- 소프트웨어의 이해를 증진시키기 위하여 시스템의 다른 관점
- 현재 보유한 문서를 개선
- 새로 수정된 프로그램의 문서화
```
---
> 설계복구<br>
- 원시코드를 자세히 검토하여 의미 있는 추상성 높은 표현을 찾아내고 추출하는 작업
---
> 리엔지니어링 목적<br>
- 시스템 또는 컴포넌트를 재구조화 하는 과정
```
<목적>
- 소프트웨어 아키텍처 개선
- 소프트웨어의 복잡도 경감
- 변경에 대한 적응성 개선
- 성능, 효율성, 자원 유용성 개선
- 소프트웨어 시스템의 유지보수 개선
```
---
> 리엔지니어링 과정<br>
```
1) 개선이 필요한 위치 파악
2) 개선 전략을 선택
3) 제안된 개선의 구현
```
---
> 작업흐름<br>
- 비즈니스 프로세스의 각 단계에서 실행해야 하는 과제들, 활동들, 책임들을 포함
---
> 작업흐름, 소비자의 기대, 경쟁환경을 이해하는 것<br>
- 경영자에게 내부나 외부의 상황이 바뀌어도 경쟁 우위를 유지할 수 있는 비즈니스 대안들을 평가할 수 있게 해줌
---
> 소프트웨어 테스트 개념과 특징<br>
- 소프트웨어 내에 존재하지만 드러나지 않고 숨어 있는 오류를 발견할 목적
- 개발 과정에서 생성되는 문서나 프로그램에 있는 오류를 여러 기술을 이용해 검출하는 작업
---
> 버그, 오류, 결합, 고장<br>
```
- 버그 : 문제, 결합 또는 난이도를 나타내는 데 일반적으로 사용되는 용어
- 오류(error) : 소프트웨어 개발자에 의해 만들어지는 실수로 결합의 원인이 됨
- 결합(defect, bug, fault) : 오류에 의해 프로그램이 완정치 못한 것으로, 고장의 원인이 됨
- 고장, 실패(failure), 문제(problem), 장애 : 시스템이 요구사항대로 작동하지 않는 것을 말함
```
---
> 소프트웨어 테스트 원리<br>
- 테스트는 오류를 발견하려고 프로그램을 실행 시키는 것
---
> 소프트웨어 테스트 작업과정<br>
- 테스트 항목 중에서 어떤 항목을 중점적으로 테스트할 것인지 명확히 나타냄
---
> 블랙박스 테스트의 동등 분할 기법<br>
```
- 입력 값에 대한 예상출력 값을 정해놓고 그대로 결과가 나오는지를 체크
- 프로그램 내부의 구조나 알고리즘을 보지 않고, 요구 분석 명세서나 설계 사양서에서 테스트 케이스를 추출하여 테스트
- 기능을 어떻게 수행하는가보다는 사용자가 원하는 기능을 수행하는가 테스트
```
---
> 블랙박스 테스트의 경계 값 분석<br>
- 경계에 있는 값을 테스트 데이터로 생성하여 테스트하는 방법
---
> 블랙박스 테스트의 원인 결과 그래프<br>
- 프로그램 명세가 의미하는 내용을 분석하여, 이에 알맞은 원인과 결과를 연결하는 논리 그래프를 작성함
---
> 화이트박스 테스트의 논리 흐름의 표현<br>
```
- 문장 검증 기준(statement coverage)
- 분기 검증 기중(branch coverage)
- 조건 검증 기준(condition coverage)
- 분기/조건 검증 기준(branch/condition coverage)
- 다중 조건 검증 기준(multiple condition coverage)
- 기본 경로 테스트(basic path test)
```
---
> 화이트박스 테스트의 검증 기준<br>
- 프로그램 내의 모든 문장이 최소한 한번은 실행 될 수 있는 테스트 데이터를 갖는 테스트 케이스를 선정
---
> 상태기반 테스트의 검증 기준<br>
```
- 같은 입력에 대해 같은 동작을 보이며 동일한 결과를 생성하는 시스템(state-less system) 을 대상
- 배치 처리 시스템
- 계산 중심 시스템
- 하드웨어로 구성된 회로
```
---
> 통합 테스트<br>
```
- 빅뱅 통합 : 모듈의 인터페이스 결합 테스트
- 하향식 통합 : 시스템 구조상 최상위에 있는 모듈부터 통합
- 상향식 통합 : 시스템 구조상 최하위에 있는 모듈부터 통합
- 연쇄식 통합 : 특정 기능을 수행하는 모듈의  최소 단위(thread)로부터 시작
```
---
> 시스템 및 인수 테스트<br>
```
- 기능 테스트 : 컴포넌트 통합 후 수행하는 테스트 기법
- 성능 테스트 : 작업 부하 - 시스템이 처리하고 생성하는 작업의 양
               처리량 - 트랜잭션의 수
               반응시간 - 시스템 요구를 처리하는데 걸리는 총 시간
               효율성 - 주어진 작업 처리를 위한 CPU시간과 메모리 같은 자원의 양의 비율
- 보안 테스트 : 시스템과 사용자에게 해를 입히려는 해커에게 이용될 수 있는 의도하지 않는 기능과 동작 시스템을 찾아내는 것
- UI 테스트 : 보고 느끼는 UI에 대한 결함
              데이터 입력과 출력 디스플레이에 대한 결함
              액터-시스템 사이의 동작 결함
              오류 처리에 대한 결함
              문서와 도움말에 대한 결함
- 인수 테스트 : 시스템을 당장 사용할 수 있도록 모든 중비가 되어 있는지 확인
               개발자를 제외한 의뢰자 또는 대리인이 테스트 수행
               시스템 요구 분석서를 기반으로 한 테스트 수행
               실제 업무 절차를 따라 테스트 수행
```
---
> 유지보수 변경의 이유와 유형<br>
```
- 개발 후에 이루어지는 소프트웨어의 변경 작업
- 소프트웨어가 유용하게 활용되는 기간
- 소프트웨어는 환경과 비즈니스 요구에 따라 진화함
- 유지보수에 드는 노력
```
---
> Lehaman의 법칙<br>
```
- 지속적인 변경의 원칙
- 엔트로피, 복작도 증가의 법칙
- 자기 통제의 법칙
- 안정성 유지의 법칙
- 친근성 유지의 법칙
- 지속적 성장의 법칙
- 품질 저항의 법칙
- 피드백 시스템의 법칙
```
---
> 유지보수 작업<br>
- 소프트웨어 개발은 코딩 중심의 작업이나 유지보수는 이해 중심의 작업, 통합된 작업
---
> 유지보수 프로세스<br>
- 독립된 유지보수 조직이 있는 경우 혼돈을 피할 수 있고, 유지보수 활동을 원활히 수행할 수 있다는 장점이 있음
---
> 프로그램의 이해<br>
```
- 원시코드로부터 설계나 명세를 추출하여 멘탈 모델로 표현하는 작업
- 개발프로세스와 반대로 추상성을 추구하는 방향
```
---
> 변경 파악과 분석<br>
```
- 변경 요구를 기초로 어떤 부분을 변경할지 찾아냄
- 다른 변경 방법(COTS)도 찾아냄
```
---
> 베이스라인<br>
- 소프트웨어 형상 관리는 소프트웨어의 개발 및 유지보수 과정에서 발생하는 각종 결과물(문서, 프로그램, 하드웨어)들에 대한 계획, 개발, 운용 등을 종합하여 시스템의 형상(모습)을 만들고, 이에 대한 변경을 체계적으로 관리, 제어하기 위한 활동
---
> 소프트웨어 형상관리 절차<br>
```
- 소프트웨어 형상 파악
- 형상 변경 제어
- 소프트웨어 형상 감사
- 소프트웨어 형상 상태 보관
```
---
> 역공학 작업순서<br>
- 대상 시스템을 분석하여 시스템의 컴포넌트와 관계를 찾아내어 같은 수준의 다른 표현이나 더 높은 수준의 표현으로 만드는 작업
---
> 역공학의 용도<br>
- 복원된 다이어그램은 다음 여러 방면에 사용
---
> 재문서화<br>
```
- 소프트웨어의 이해를 증진시키기 위하여 시스템의 다른 관점
- 현재 보유한 문서를 개선
- 새로 수정된 프로그램의 문서화
```
---
> 설계 복구<br>
- 원시코드를 자세히 검토하여 의미 있는 추상성 높은 표현을 찾아내고 추출하는 작업
---
> 리엔지니어링 목적<br>
- 시스템 또는 컴포넌트를 재구조화하는 과정
```
- 소프트웨어 아키텍처 개선
- 소프트웨어의 복잡도 경감
- 변경에 대한 적응성 개선
- 성능, 효율성, 자원 유용성 개선
- 소프트웨어 시스템의 유지보수 개선
```
---
> 리엔지니어링 과정<br>
```
- 개선이 필요한 위치 파악
- 개선 전략을 선택
- 제안된 개선의 구현
```
---
> 작업흐름<br>
- 비즈니스 프로세스의 각 단계에서 실행해야 하는 과제들, 활동들, 책임들을 포함
```
- 작업흐름, 소비자의 기대, 경쟁 환경을 이해하는 것 -> 경영자에게 내부나 외부의 상황이 바뀌어도 경재 우위를 유지할 수 있는 비즈니스 프로세스 대안들을 평가할 수 있게 해줌
```
---
> 소프트웨어 품질 개념과 특징<br>
- 소프트웨어의 유용성(fitness for use)을 얻기 위해 갖추어야 하는 특성들의 집합이며, 소프트웨어가 사용자의 요구사항을 충족시키기 위하여 갖추어야 할 제반 특성을 의미
---
> 소프트웨어 품질 구성요소<br>
```
- 소프트웨어의 유용성 및 사용 목적을 달성하는 데 필요한 성질을 소프트웨어의 품질요소라 할 수 있음
- 소프트웨어도 일반적인 제품에서 필요로 하는 품질 요소가 적용될 수 있고, 특히 소프트웨어가 가지고 있는 특성상 특정 품질 요소가 추가될 수 있음
- 일반적으로 품질은 소프트웨어의 운용에서 나다나는 특성, 소프트웨어의 수정에서 요구괴는 특성, 새로운 환경에 대한 적응성의 3가지 중요한 측면에서 관찰될 수 있음
```
---
> 소프트웨어 품질 모델<br>
- 제품 품질 특성 평가
```
- 완성된 제품에 대한 평가
- ISO/IEC 9126에서 제시하는 모델이 소프트웨어 품질에 대한 표준적인 모델
```
- 프로세스 품질 특성 평가
```
- 소프트웨어 제품의 개발 프로세스를 평가
- 소프트웨어 개발 과정의 각 단계마다 평가
```
---
> 소프트웨어 품질 보증 개념과 특징, 근본조직<br>
- 소프트웨어 제품이나 아이템이 정해진 요구에 적합하다는 것을 보장하는 데 필요한 계획적이고 체계적인 활동
---
> 프로세스와 표준을 정의<br>
```
- 소프트웨어 개발, 품질 관리 프로세스 및 방법론의 정의
- 개발 주기 동안 품질보증 작업을 수행할 표준, 절차, 가이드라인의 정의
- 품질 측정과 평가를 위한 품질 메트릭, 지표 정의
```
---
> 소프트웨어 품질 보증 활동<br>
```
- 품질 계획 : 프로젝트 초반에 이루어지는 활동, 특정 프로젝트에 대한 품질 계획을 작성
- 품질 제어 : 프로젝트 전반에 걸쳐 이루어짐, 품질 계획의 실행을 모니터링하고 현실적으로 수정이 필요하면 품질 계획을 수정
```
---
> 인스펙션<br>
- 품질 개선과 비용 절감을 위한 기법으로 사용
---
> 소프트웨어 품질 측정의 유용성<br>
```
- 소프트웨어 측정 : 소프트웨어 속성의 객관적이고 정량적인 평가
- 소프트웨어 메트릭 : 표준화된 소프트웨어 측정 방법
```
---
> 소프트웨어 품질 메트릭<br>
```
- 요구의 비모호성(unambiguity)
- 요구 완전성 메트릭-요구 명세서에 기술된 시스템의 상태와 시스템에 대한 외부자극이 완전하다는 가정에 근거
- SRS : 시스템의 모든 가능한 상태와 모든 가능한 외부자극을 포함
- f함수가 완벽하게 매핑된다면 SRS는 완벽한 것으로 간주
```
---
> CMMI<br>
```
- 조직의 프로세스 개선을 위해 개발
- 기업에 표준 프로세스를 만들 수 있는 지침을 제시하고, 그 기준이 됨
```
---
> ISO9001<br>
- ISO 9001 은 외부품질 보증 목적에 사용될 수 있는 품질시스템 요구사항에 관한 3가지 규격 중 하나로 설계, 개발, 생산, 설치 및 서비스 분야에 적용되는 품질기준 지침을 제공
---
> 정보시스템 감리의 개념과 특징<br>
```
- 공공부문의 주요 정보시스템에 대한 감리를 의무화
- 권고 -> 감리 결과 반영 및 감리기준 준수 등을 의무화
- 기술능력과 재정능력을 갖춘 감리법인이 감리를 수행(법인 책임주의)
- 감리법인,감리원 등록 등 감리제도를 체계화함
-- 감리법인의 등록 및 변경 신고에 대한 의무를 부과
-- 감리원의 자격 요건을 규정하고 감리 교육 이수 의무 부과
-- 부실감리 등에 대한 행정처분(등록 취소, 업무정지) 및 벌칙 부과
```
---
> 정보시스템 감리 기준<br>
```
- 주요 공공 정보시스템 감리를 의무화(법 제57조1)
- 정보시스템의 특성, 사업의 규모 측면에서 판단 기준을 제시
- 규모 기준 : 사업비(HW,SW의 단순구입비 제외) 5억원 이상인 정보시스템 구축사업
- 특성 기준 : 대국민 서비스/민원업무  ,   다수기관 공동 구축,사용
```
---
> 정보시스템 감리 수행<br>
- 요구정의 -> 설계 -> 




































